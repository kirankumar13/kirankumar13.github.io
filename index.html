<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Chapter 9</title>
</head>
<body>
<div id="wrapper">
    <div id="container">

        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p>
               The user of the You Are What You Eat program has more trouble recalling what he ate than anticipated. He also wonders if the computer can keep
                track of the fat and calories in each thing he eats so that he only has to enter it once. This case study describes how a programmer might respond to problems encountered by users. What does “user-friendly” really mean?
              </p>
              <h2 style="color: #e0214d;background: lavenderblush;">Problem Statement</h2>
              <p>
                We encounter Terry a few days after giving him the You Are What You Eat program.<br>
                MIKE AND MARCIA: How’s the program working out?<br>
                TERRY: It’s OK, but ... (pause)<br>
                MIKE AND MARCIA: We wouldn’t mind trying to improve the program a bit,if you have some things to suggest.<br>
                Terry: Well, I always have to look up the amounts of fat and calories each food I eat has. can you make the program do that instead?<br>
                MIKE AND MARCIA: That would be possible. You would want to enter the food and how many servings of it you had, right.Then the program would
                report how much fat and how many calories you had eaten?<br>
                Terry: Right.<br>
                MIKE AND MARCIA: All the information for each food would be stored in a disk file. There will be a lot of it. Do you have room on your disk?
                Terry: I think so.<br>
                MIKE AND MARCIA: Are you having any other problems with the program?<br>
                TERRY: It would be nice to be able to print a copy of the graph the program produces.<br>
                MIKE AND MARCIA: That’s possible too. You can get printed versions of text files on your computer, right? What else?<br>
                Terry: On Friday, after running the program, I remembered something else I ate. Then I was gone all day on Saturday, and I was too tired to run
                the program when I got home. When I ran the program on Sunday I put in Sunday’s foods before Saturday’s, so they were out of order. To fix the
                problem, I edited the history file with my text editor even though you told me not to. I made a mistake, so when I ran the program it crashed. I knew<br>
              </p>
             




                   </article>
            <footer>
                <ol id="page-numbers">
                    <li>1</li>
                    <li>2</li>
                </ol>
            </footer>
        </section>


        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p>
                it was my fault so I fixed the file, but I was worried that I had messed up something somehow.
              </p>
              <p>
                MIKE AND MARCIA: Calm down, it’s OK, no harm done. Suppose we write a program that will let you change what’s in the file. It can give you a chance
                to correct any mistakes you make and add stuff you forget.
              </p>              
              <p>
                TERRY: That would be great!
              </p>
              <p>
                MIKE AND MARCIA: OK, give US another day or two.
              </p>
               <h3 style="color: #e0214d;">Analysis</h3>
               <p>
                 8.1 What additional questions might the programmers have asked Terry in order to clarify the planned modifications?
               </p>
               <h3 style="color: #e0214d;">Analysis</h3>
               <p>
                 8.2 What additional features might help the user of the program?
               </p>
               <h3 style="color: #e0214d;">Analysis</h3>
               <p>
                 8.3 What should the program do about foods that are not found in the food information file?
               </p>
               <h3 style="color: #e0214d;">Analysis</h3>
               <p>
                 8.4 Sketch an interaction between Terry and the revised program.
               </p>
               <h3 style="color: #e0214d;">Reflection</h3>
               <p>
                 8.5 What are the drawbacks to this process of trial and refinement of the program?
               </p>
               <h3 style="color: #e0214d;">Reflection</h3>
               <p>
                 8.6 What kinds of programs benefit from the process of trial and refinement used to develop this program?
               </p>
               <h2 style="color: #e0214d;background: lavenderblush;">Preparation</h2>
               <p>
                 Solutions in this case study use files of records, along with arrays. This case study introduces the use of enumerated types, along with the pred
                  and succ functions.
               </p>
               <h2 style="color: #e0214d;background: lavenderblush;">Planning the Modifications</h2>
                <h3 style="color: #e0214d;">What new features were requested? </h3>
               <p>
                 Terry requested three new features to make the program more useful:
               </p>
               <ul>
                <li>
                  Rather than requiring the user to enter fat and calories for each food eaten, the program should ask for the name of the food and the number
                  of servings eaten, and look up the food in a file. From the information stored in the file, the program should compute the fat and calorie
                  amounts for the food.
                </li>
                <li>
                  Rather than just showing the graphs of fat and calories use on the screen, the program should also create a fde that can be printed.
                </li>
                <li>
                  Rather than assuming that the input from the history file is correctly organized, the program should allow the user to correct errors and insert
                  data into the history file
                </li>
              </ul>
               <h3 style="color: #e0214d;">Stop & Help </h3>
               <p>
                <i>
                  Why didn't Terry ask for these features in the first place?
                </i>
                 
               </p>
               <p>
                 To determine how to add these features to the program, we review the program structure, expressed in the call diagram below.
               </p>
               <h3 style="color: #e0214d;">Stop & Predict </h3>
               <p>
                 <i>
                   What parts ofthese changes require only recycling prior solutions?
                 </i>
               </p>
                <h3 style="color: #e0214d;">changes will produce a file containing the graphs? </h3>
                <p>
                  Printing the graphs to a file involves just recycling the solution for printing to the screen. The PrintGroph procedure is the obvious place to add code.The change involves adding a rewrite statement to initialize the file, and duplicating each write and writein statement to write to the file as well as to the screen. A good name for the file is grophFile. A new question for Terry is whether he has a file by this name. Once the files are created,Terry can print them using whatever procedure he normally uses to print text files.
                </p>
                <p>
                  Questions for Terry
                </p>
                <ul>
                  <li>
                    Do you (or will you ever) have a file named graphFile?
                  </li>
                </ul>
                <h3 style="color: #e0214d;">Stop &Help</h3>
                <p>
                  <i>
                    Why do we need to ask Terry ifhe has a file named graphFile?
                  </i>
                </p>














            </article>
               <footer>
                <ol id="page-numbers">
                    <li>3</li>
                    <li>4</li>
                </ol>
            </footer>
        </section>


        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>                  
                  How do you get printed versions of text files created by programs on your computer system?
                </i>
              </p>
              <h3 style="color: #e0214d;">What changes will implement the new input format?</h3>
              <p>
                The main change to the input is entering a food name and serving size rather than entering fat and calories. The code in You Are What You Eat can
                be almost completely recycled.
              </p>
              <p>
                The input procedures all have names starting with “read.” ReadEntry calls ReadFat and ReodColories to get values for fat and calories for a food; each of those procedures calls ReodTrimnnedLine to read a line from the user.
              </p>
              <p>
                The program should still read lines from the user, so ReadTrimnnedLine should work for the new input. ReadTrimmedLine can be used in the
                 revised program to read a line containing “ice cream” or “broccoli.” Read Food and ReodServings are obvious replacements for ReadFat 
                 and ReadCalories.
              </p>
              <p>
                After reading a food name, the program should search the food information file to determine the values to return to ReodEnfry. We’ll assume that
                the food information file is called foodinfo; this name must be checked with Terry.
              </p>
              <h3 style="color: #e0214d;">Stop & Predict</h3>
              <p>
                <i>
                  What details are being postponed here
                </i>
              </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  What changes to the error-checking procedures are needed?
                </i>
              </p>
              <h3 style="color: #e0214d;">What changes will allow the user to add forgotten data and correct errors?</h3>
              <p>
                To change or correct data, Terry needs to be able to edit the history file.Currently the program allows the user only to add the current day’s data
                to the history file. Providing an editing feature means providing a way to add data for other dates to the file and to select data already in the file in order to update it. Updates will have to be reflected in the graphs produced by the program. The current program accesses only the most recent 30 days’ data, but Terry might decide to change data gathered much earlier. This feature changes the way Terry will interact with the program
                and requires more than recycling the prior solution.
              </p>
                <h3 style="color: #e0214d;">Stop & Predict</h3>
                <p>
                  <i>
                    Should thefile editing function be added to the existingprogratn or addressed in a new program?
                  </i>                  
                </p>
                <h3 style="color: #e0214d;">How might the modifications be incorporated?</h3>
                <p>
                  We consider the alternatives of adding the editing feature to the current program or creating a new program to edit the history file. Either approach has advantages. Having a separate program and thereby creating a system of programs—results in two smaller programs rather than one big program.It requires (at least in Standard Pascal) that copies of common code occur in each program. If, for instance, the format of the history file were changed, the new format would have to be implemented in two places 
                </p>
                <p>
                  It’s not clear which option is better for Terry. He might not be able to predict whether it would be easier to use two programs or one program; he
                  would probably want to know more about how the programs would work.
                </p>
                <p>
                  We will create a separate program, which we’ll call the history file editor, to update the history file. Creating two programs helps to communicate that each program performs a separate function and is, therefore, more intuitive for the user. The You Are What You Eat program will continue to handle the normal situation in which the current day’s data is collected and the history displayed in graphs. The history file editor will be available for the exceptional situation of changing previously entered data.
                </p>
                <p>
                  We can postpone the implementation of the history file editor until we finish updating You Are What You Eat. However, providing the editing 
                  facility may have implications for You Are What You Eat, so we keep the editing program in mind while making the modifications.               
                                   
                </p>
                <h3 style="color: #e0214d;">Stop & Help</h3>
                <p>
                  What criteria would Terry use to decide about one ortwoprograms?How are these differentfrom the criteria used by a programmer?
                </p>
                 <h3 style="color: #e0214d;">Stop & Consider</h3>

                <p>
                  <i>
                    Compare the approach weWe about to take with the approach of having a single program do all the data collection and updating, and anotherprogram produce the graphs andstatistics.
                  </i>
                </p>
                <h3 style="color: #e0214d;">How will the history file editor work?</h3>
                <p>
                  The history file editor will repeatedly read and execute commands from the user. The commands will be such things as “list history entries,”
                  “change this entry,” and “add an entry.”
                </p>
                 <h3 style="color: #e0214d;">How will the history file format change?</h3>
                 <p>
                   Terry seems to think of entries by date. To make the interface intuitive,the entries should be identified by date. For example, the “change” 
                   command should be “change the entry for a given date.”
                 </p>
                 <p>
                   In designing You Are What You Eat we decided not to store the date because it was redundant with the sequence of entries. Now there is a need
                    for the date because an entry might be missing or incomplete. Thus, to implement the file editor we need to add the date to each file entry. This means changing You Are What You Eat to include the date with each entry.
                 </p>
                  <h3 style="color: #e0214d;">How will the dote for the current entry be determined?</h3>
                  <p>
                    
                    Figuring out the date for the file entry about to be added can be done in several ways.
                  </p>
                  <ul>
                    <li>
                      The You Are What You Eat program can figure it out from the information stored in the history file.
                    </li>
                    <li>
                      The program can ask the user.
                    </li>
                    <li>
                      Some Pascal environments provide a procedure to retrieve the current date from the operating system. (Of course, this could cause problems
                      if the data being input is not for the current date.)
                    </li>












              
             
            </article>
            <footer>
                <ol id="page-numbers">
                    <li>5</li>
                    <li>6</li>
                </ol>
            </footer>
        </section>

        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p>
                 Terry intends to record information for every day. Thus the most intuitive approach is to verify that the information to be recorded is for the “next” day. The program should determine the date from the history file by computing the day after the date of the most recent file entry. The programs should either print the date or ask the user to verify the date. We add this choice to the list we have for Terry.
               </p>
               <h3 style="color: #e0214d;">Stop & Help</h3>
               <p>
                 <i>
                   Why is this a question that Terry can answer while choosing between one and two programs was not?
                 </i>
               </p>
               <p>
                 Questions for Terry
               </p>
               <ul>
                <li>
                  Do you (or will you ever) have a file named graphFile?
                </li>
                <li>
                  Do you (or will you ever) have a file named foodlnfo?
                </li>
                <li>
                  Is it OK for the program to display the date it will store for the current entry and have you verify it?
                </li>
              </ul>
               <h3 style="color: #e0214d;">What modifications are needed to go with the new file format?</h3>
               <p>
                 In designing You Are What You Eat we isolated references to the data structures so that it would be easy to update them without making major
                changes in the program. The Initialize procedure reads from historyFile, and the Update procedure writes to the file. These are the two main places
                where changes are needed.
               </p>

               <h3 style="color: #e0214d;">Stop & Predict</h3>
               <p>
                 <i>
                   What other parts of the program are likely to need changes to accommodate the updated file format?
                 </i>
               </p>
               <h3 style="color: #e0214d;">What comes first?</h3>
               <p>
                 A beneficial aspect of the way we designed the program is that the rewritten version of ReodEnfry can be tested and debugged independent of the
                  other revisions. The same holds for the change to PrintGraph. We will thus make these revisions before implementing the date-handling code, which
                  seems to require more changes to the program.
               </p>
                <h3 style="color: #e0214d;">Analysis</h3>
                <p>
                  8.7 Suppose that instead of locating a data file on fat and calories Terry wanted to store the information he entered and add new information
                  only for new foods. How would this change the way the program was updated?
                </p>
                <h3 style="color: #e0214d;">Reflection</h3>
                <p>
                  8.8 How might the need for the date in the history file have been anticipated in the first version of You Are What You Eat?
                </p>



                <h3 style="color: #e0214d;">What changes to You Are What You Eat are to be made?</h3>
                <p>
                  Planned changes to You Are What You Eat are summarized as follows:
                </p>
                <ul>
                  <li>
                    ReadEntry will be rewritten to read from the user the name and number of servings of a food and to look up the corresponding fat and calorie
                    amounts in foodinfo, the file of food information. Procedures ReadFat and ReadCalaries will be replaced by procedures ReadFood and ReadServings
                  </li>
                  <li>
                    PrintGraph will be revised to print the graphs to a file as well as to the terminal screen.
                  </li>
                  <li>
                    Initialize will be modified to include a date as part of each file entry read from historyFile, to define a date for the current day’s file entry, and to inform the user of the date.
                  </li>
                  <li>
                    Updote will be modified to include a date as part of each file entry written to tempFile and historyFile
                  </li>
                  <li>
                    A date will be included in EntryType.
                  </li>
                </ul>
                   <h3 style="color: #e0214d;">Stop & Predict</h3>
                   <p>
                     <i>
                       How do these changes influence the decomposition ofYon Are What You Eat?
                     </i>
                   </p>
                   <h3 style="color: #e0214d;">Stop & Predict</h3>
                   <p>
                     <i>
                       
                       Which changes are minor and which are major?
                     </i>
                   </p>
                   <h2 style="color: #e0214d;background: lavenderblush;">Implementing Changes to You Are What You</h2>
                    <h3 style="color: #e0214d;">How is PrintGraph</h3>
                    <p>
                      We start with the easiest change, updating PrinfGroph. The only change needed is to add a rewrite statement and to duplicate all the write and
                      writein statements as follows.
                    </p>
                    <p>
                      write ( ... ) ;
                      is duplicated as
                      write ( ... );
                      write (graphFile, ... );
                      and
                      writein ( ... ) ;
                      is duplicated as
                      writein ( ... );
                      writein (graphFile, ... );
                    </p>
                     <h3 style="color: #e0214d;">Stop & Help</h3>
                     <p>
                       <i>
                         Test the code using the test data designed in You Are What You Eat.
                       </i>
                     </p>
                     <h3 style="color: #e0214d;">How is ReadEntry rewritten?</h3>
                     <p>
                       The old version of ReadEntry called ReadFat and ReodColories to read fat and calorie values from the user. It makes sense to retain this structure by calling ReadFood first, then ReadServings. At some point the specified food name must be looked up in foodinfo and associated with fat and calorie figures. These would then be accumulated in the same way as in the original program. Here is a pseudocode design:
                     </p>
                     <p style="font:16px Courier New">
                      entry.fat := 0;
                      entry.calories := 0;
                      repeat
                    </p>

             </article>


            <footer>
                <ol id="page-numbers">
                    <li>7</li>
                    <li>8</li>

                </ol>
            </footer>
        </section>


        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                     <p style="font:16px Courier New">
                     ReadFood (inFile, food, done);
                    if not done then begin
                    ReadServings (inFile, numServings);
                    entry, fat := entry, fat + numServings * for from food ;
                    entry, calories := entry .calories + numServings * colories from food ;
                    end;
                    until done;
                    </p>
                    <h3 style="color: #e0214d;">In which procedure should the ReadEnfoodbe looked up?</h3>
                    <p>
                      Lookup of the food name entered by the user then must occur in ReadEntry,ReadFood, or ReadServings.
                    </p>

                   <h3 style="color: #e0214d;">Stop & Predict</h3>
                    <p>
                      <i> 
                        Which procedure should contain the lookup code?
                      </i>
                    </p>
                    <p>
                      ReadServings would be a poor choice. The number of servings is not related to the kind of food. ReodEntry is a possibility; immediately prior to the call to ReadServings, we might insert code to search the food file.
                    </p>
                    <p>
                      The best choice,however, is ReadFood. Recall that ReadFat and ReadColories were designed to return legal values for fat and calories to ReadEntry in the original program. Thus ReadFood should similarly return a legal food to ReodEntry. A food that isn’t in the food file is illegal.
                    </p>
                    <h3 style="color: #e0214d;">Stop & Help</h3>
                    <p>
                      <i>
                        What kinds oferrors should be detected for the food name?
                      </i>
                    </p>
                    <h3 style="color: #e0214d;">What is the format of the food information file?</h3>
                    <p>
                      As long as ReadFood is looking up the food name, it might as well return the entire entry from foodinfo. Thus foodinfo should be structured to
                      make this easy. The food name, something about a serving size, and the corresponding fat and calorie values should be stored together in foodinfo so that once the name is found, all the other information for the food will be immediately available. One way to represent foodinfo would then be as lines of text, each containing information for one food, for instance:
                    </p>
                     <p style="font:16px Courier New">
                      broccoli, raw; 1 spear; 40; 0
                    </p>
                    <p>
                      The semicolons are separators for the various pieces of food information.The problem with this format is extracting the components from the line of text.
                    </p>
                    <p>
                      A better approach is to impose more structure on the file by making it  a file of records. Reading a record would involve reading each of the components. Though such a file could not be printed or edited with a text editor,that’s fine; the user need not meddle with the file except through this program. The file can be defined as
                    </p>
                      <p style="font:16px Courier New">
                        type
                        StringType = array [1..MAXSTRLEN] of char;
                        FoodEntryType = record
                        foodName: StringType;
                        servingDescr: StringType;
                        fat, calories: integer;
                        end;
                        FoodInfoType = file of FoodEntryType;
                        </p>
                        <h3 style="color: #e0214d;">How is a file of records created?</h3>
                        <p>
                          A program is needed to create a file of records—a text editor cannot do it. The program is straightforward, however. All that is needed is a loop containing some input statements and a statement that writes the input values to the file.
                        </p>
                        <h3 style="color: #e0214d;">How is the error checking coded?</h3>
                        <p>
                          The input and error-checking code that uses this file would then be patterned on code in ReodFot as follows. It uses a Search procedure that returns either a food entry or an indication that none was found in foodinfo.
                        </p>
                        <p style="font:16px Courier New">
                          done := false;
                          repeat
                          error := false;
                          writeln('Please type either a food name');
                          writeln('or type the word "done"--without the quotes--');
                          writeln('if you''re finished.');
                          ReadTrimmedLine (line);
                          if Empty (line) then begin
                          error := true;
                          end else if Equal (line, DONESTR) then begin
                          done := true;
                          end else begin
                          Search (line, foodEntry, found);
                          if not found then begin
                          error := true;
                          end;
                          end;
                          if error then begin
                          writeln('That food is not in the dictionary of foods.');
                          end;
                          until done or not error;

                        
                        </p>
                        <p>
                          On exit from the loop, either the user has typed “done,” and therefore done is true, or the user has typed a recognized food name, foodEntry contains the information for that food, and done and error are both false.
                        </p>
                       <h3 style="color: #e0214d;">Stop & Help</h3>
                       <p>
                         <i>
                           Is theprompt sufficient to tell the user that input like ''slice ofcake'' is probably inappropriate? Why or why not?
                         </i>
                       </p>
                       <h3 style="color: #e0214d;">How is the file search coded?</h3> 
                       <p>
                         The Search procedure searches the foodinfo file for an entry matching the given name. It is similar to linear search in an array:
                       </p>
                        <p style="font:16px Courier New">
                          procedure Search (line: LineType;
                          var foodEntry: FoodEntryType; var found: boolean);
                          begin
                          reset (foodinfo);
                          found := false;
                          while not eof and not found do begin
                          read (foodinfo, foodEntry);
                          found := Equal (line, foodEntry.foodName);
                          end;
                          end;

                        </p>
                        <h3 style="color: #e0214d;">How are the fat and calorie amounts coded?</h3> 
                        <p>
                          The number of servings is read in the same way, using ReadTrimmedLine, IsAIIDigits, and IntegerVolue, as were the fat and calorie amounts in the original program.
                        </p>





            </article>
            <footer>
                <ol id="page-numbers">
                    <li>9</li>
                    <li>10</li>
                </ol>
            </footer>
        </section>

        
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p>
                For a good user interface, the prompting message should indicate what a serving is, so the program should write the servingDescr field
                in foodEntry. Once converted to an integer, the input value should be checked for reasonableness: it should be at least 1 and probably less than
                100 or so. Here’s the code.
              </p>
              <p style="font:16px Courier New">
                repeat
                error := false;
                write ('How many servings? (One serving =
                foodEntry.servingDescr, ') ');
                ReadTrirranedLine (line) ;
                if Empty (line) then begin
                error := true;
                end else if not IsAllDigits (line) then begin
                error := true;
                end else begin
                numServings := IntegerValue(line);
                if not IsInServingRange (numServings) then begin
                error := true;
                end;
                end;
                if error then begin
                writeln ('You must provide an integer number of servings.')
                end;
                until not error;
              </p>
              <p>
                Back in ReodEntry, the number of servings should be multiplied by foodEntry.for to compute a fat amount and by foodEntry.calories to compute a
                calorie amount. Both amounts should be accumulated until the user is finished entering input.
              </p>
               <h3 style="color: #e0214d;">How is code tested?</h3>
               <p>
               The revised Bead... routines appear in the Pascal Code section. We test them as follows. First we write a program to create foodlnfo; a file contain¬
                ing four elements should be sufficient to check boundary cases. Then we write a main program that repeatedly calls ReadEntry and prints the resulting fat and calorie figures. The only really new code is Search, so it must be tested most carefully; we make sure to check for foods at the start, at the end, and somewhere in the middle of foodlnfo.
              </p>
             <h3 style="color: #e0214d;">Stop & Help</h3>
             <p>
               <i>
                 Write the program to create foodlnfo
               </i>
             </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  Write the main program to test ReodEntry
                </i>
              </p>
               <h3 style="color: #e0214d;">What modifications are necessary to keep track of dates?</h3>
               <p>
                 Including dates in the history file requires more widespread change to the program than was true for the other updates.
               </p>
               <p>
                 A date consists of a month, a day, and a year. A good structure for storing a date is a Pascal record with three fields. In Pascal, we may then make the following definitions:
               </p>
                <p style="font:16px Courier New">
                  type
                  MonthTVpe = (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE
                  JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER);
                  DayType = 1. .31;
                  YearType = 1990..2100;
                  DateType = record
                  month: MonthType;
                  day: DayType;
                  year: YearType;
                  end;
                  EntryType = record
                  date: DateType;
                  fat, calories: integer;
                  end;
                  HistoryType = array [0..HISTORYSIZE] of EntryType;
                  </p>
                  <p>
                    For clarity, we use subranges to represent days and years. We also use Pascal’s enumerated type facility to represent months. In The Calendar Shop,integer constants were used for this purpose. The main difference here is that an enumerated type can be defined somewhat more concisely.
                  </p>
                   <h3 style="color: #e0214d;">Stop & Predict</h3>
                   <p>
                     <i>
                       What are the advantages ofmaking the history file afile of records?
                     </i>
                   </p>
                   <p>
                     In the first version of the program, the history file was of type text. It makes sense to have it be a file of records like the food information file,since it will always be read and updated under control of one of the programs we write. Thus, one more definition:
                   </p>
                   <p style="font:16px Courier New">
                    HistoryFileType = file of EntryType;
                  </p>
                    <h3 style="color: #e0214d;">Stop & Help</h3>
                    <p>
                      <i>
                        Write aprogram to create a version c?/historyFile to use for testing the updated program.
                      </i>
                    </p>
                    <p>
                      We will have to get together with Terry to copy the fat and calorie data collected so far to a file in the new format.
                    </p>
                     <h3 style="color: #e0214d;">How will Initialize and Update be modified to handle the new file format?</h3>
                     <p>
                       In You Are What You Eat, we considered and rejected the option of initializing the file to contain at least 30 entries, then using a far loop in Initialize.This allowed for the possibility that a desperate user would edit the history file and remove some of the lines. Since editing a file of records is impossible, we return to the simpler code:
                     </p>
                     <p style="font:16px Courier New">
                      for dayNum := 1 to HISTORYSIZE do begin
                      readln (historyFile, recentHistory[dayNum] .fat,
                      recentHistory[dayNum].calories);
                      end
                    </p>
                    <p>
                      Three revisions are necessary. The histaryFile parameter is now of type HistoryFileType. The read procedure must be used instead of readln, sinee input is no longer coming from a text file. Instead of reading the fat and calorie components separately, the code reads each record from the file in its entirety. Here is the rewritten code:
                    </p>
                     <p style="font:16px Courier New">
                      reset(historyFile);
                      for dayNum := 1 to HISTORYSIZE do begin
                      readhistoryFile, recentHistory[dayNum]);
                      end;
                    </p>

                </article>
            <footer>
                <ol id="page-numbers">
                    <li>11</li>
                    <li>12</li>
                </ol>
            </footer>
        </section>

        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
            	  
              <p>
                The Update procedure is revised in similar ways: historyFile is defined as a HistoryFileType, and read and write statements taking a file and a record argument are used instead of reodln and writeln.
              </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  Modify Update as just described.
                </i>
              </p>
              <h3 style="color: #e0214d;">How is the date of the current entry computed?</h3>
              <p>
                Next the current date must be determined, by computing the successor of the date in recentFlistory[1 ], and then printed. A procedure to find the date,which uses code from The Calendar Shop, is the following:
              </p>
              <p style="font:16px Courier New">
                procedure FindSuccessor (current: DateType; var next: DateType);
                begin
                if current.day < NuinberOfDaysIn (current.month) then begin
                next.month := current.month;
                next.day := current.day + 1;
                next.year := current.year;
                end else if current.month < DECEMBER then begin
                next.month := succ (current.month);
                next.day := 1;
                next.year := current.year;
                end else begin
                next.month := JANUARY;
                next.day := 1;
                next.year := current.year + 1;
                end;
                end
              </p>
              <p>
                The succ function is used to determine the successor of the enumerated type value.
              </p>
              <h3 style="color: #e0214d;">What changes to the top-level decomposition are necessary?</h3> 
              <p>
                A remaining question is where to put the code that determines the current date and stores it in a file entry. The original decomposition was
              </p>   
              <p style="font:16px Courier New">
                ReadEntry (entry);
                Initialize (historyFile, entry, recentHistory);
                PrintAverages (recentHistory)
                PrintGraph (recentHistory);
                Update (historyFile, recentHistory);

              </p>
              <p>
                However, we would like to inform Terry of the current date before he starts entering data. That suggests that the first two procedure calls be reversed:
              </p>
              <p style="font:16px Courier New">
                Initialize (historyFile, entry, recentHistory);
                ReadEntry (entry);
              </p>
              <p>
                The entry to be read, however, is recenfHistory[0], which suggests the following code:
              </p>
              <p style="font:16px Courier New">
                Initialize (historyFile, recentHistory);
                ReadEntry (recentHistory[0], recentHistory[1].date);
              </p>
              <p>
                In this decomposition, Initialize would fill elements 1 through 30 of recentHistory,and ReodEntry would be given an entry to fill and a date to print
                and store into that entry
              </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  What do you think of this decomposition?
                </i>
              </p>
              <p>
                The problem with this code is that it increases the number of places in the program that access recentHisfory directly. Our design all along has aimed to minimize and localize such accesses. In the original program, neither the main program nor ReodEntry needed to know exactly how recentHistory was represented, and we would like to maintain that localization.
              </p>
              <h3 style="color: #e0214d;">Stop & Predict</h3>
              <p>
                <i>
                  How should the code be organized to limit direct accesses to recentHistory?
                </i>
              </p>
              <p>
                The solution is to call ReadEntry from inside Initiolize. The code below would immediately follow the for loop;
              </p>
               <p style="font:16px Courier New">
                FindSuccessor(recentHistory[1].date, today);
                write('The food data you are about to enter is assumed to be for ');
                WritelnDate(today);
                write('Quit this program and run the history file editor');
                writeln(' if this is incorrect.');
                ReadEntry(input, today, recentHistory[0]);

              </p>
              <p>
                ReadEntry must still be modified to take an extra argument, the date to be stored in the entry.
              </p>
              <p>
                Designing a procedure WritelnDate to print the date is straightforward. It together with the other code just designed, appears in the Pascal Code
                section. The call diagram appears in Figure 8.1; subprograms that were revised or added are boxed.
              </p>
               <h3 style="color: #e0214d;">How is the code tested?</h3>
               <p>
                 The initializing and updating code is tested as in You Are What You Eat.Other tests should exercise all parts of the FindSuccessor procedure; thus
                  we should provide test files whose most recent entry occurs in the middle of a month, at the end of a month, and at the end of the year.
               </p>
               <p>
                 The complete program is over 500 lines long. A single DEBUGGING true-or false switch isn’t enough; it would generate either no output or too much.
                What we’d like is a selective debugging facility that could be used to generate debugging output only for a particular section of code.
               </p>
               <p>
                 One way to do this is to define the DEBUGGING constant as an integer interpreted as an indicator of which code is being debugged. A value of 1
                might mean that the history file operations are being debugged, 2 might mean the date code, and so on. We would define constants to give names to these values and then include code like
               </p>









            </article>
            <footer>
                <ol id="page-numbers">
                    <li>13</li>
                    <li>14</li>
                </ol>
            </footer>
        </section>


        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p>
                  A problem with this approach is that DEBUGGING can take on only one value at a time. We have used the debugging switch not only to produce extra
                  output, but also to cause input to be read from a test file rather than the terminal. It is likely that we’d want both to happen simultaneously during some test runs.
                </p>
                <p>
                For this program, we choose a simpler approach, that of having more than one debugging constant. The ones used in the Pascal Code section are
                listed below.
              </p>
              <h3 style="color: #e0214d;">Testing</h3>
              <p>
                8.9 Make a table of tests needed for the program and indicate the values that would be tested.
              </p>
              <h3 style="color: #e0214d;">Modification</h3>
              <p>
                8.10 Modify the program to print both the day (e.g. Sunday or Monday) and the date of the next entry.
              </p>
              <h3 style="color: #e0214d;">Modification</h3>
              <p>
                8.11 Modify the program to ask the user to verify the next date and to enter a different date if necessary.
              </p>
              <h3 style="color: #e0214d;">Modification</h3>
              <p>
                8.12 Add a procedure called FoodMotch to this code that searches foodinfo for the first five letters of a food name and asks the user if the correct
                record has been located
              </p>
              <h3 style="color: #e0214d;">Modification</h3>
              <p>
                8.13 Modify the program to accept and process fractional serving sizes. What are the optionsfor representing the history entries?
              </p>
               <h2 style="color: #e0214d;background: lavenderblush;">High-Level Design of the History Editor</h2>
                <h3 style="color: #e0214d;">What commands will be provided in the history file editor?</h3>
                <p>
                  To edit the history file Terry needs to add, change, and delete information. Changing is really no more than deleting and adding, so to keep things simple we include only the odd and delete commands:
                </p>
                <p>odd date</p>
                <p>
                  Add an entry for the given date. The program will request two integer values, one for fat and one for calories. It is an error if there is al¬
                  ready an entry with the given date in historyFile.
                </p>
                <p>delete dote</p>
                <p>
                  Delete the entry for the given date. The program will print a message giving the date deleted and the values for calories and fat. It is
                  an error if there is no entry with the given date in historyFile.
                </p>
                 <h3 style="color: #e0214d;">Stop & Predict</h3>
                 <p>
                   <i>
                     What other commands might users want?
                   </i>
                 </p>                
                 <p>
                   Terry will also wish to check to be sure an entry is accurate. Commands
                    that allow segments of the history file to be displayed will help here:
                    list<br>
                    Print all entries in historyFile.
                    list date<br>
                    Print the entry for the given date; print an error message if there is
                    no entry in historyFile for the date.
                    list start-date end-date
                    Print all entries in historyFile with dates between those specified;
                    print an error message if no entries are in the specified range.
                    We figure the user may forget the commands so we provide help with a
                    help command:
                    help<br>
                    Print a list of legal commands.
                 </p>





            </article>
            <footer>
                <ol id="page-numbers">
                    <li>15</li>
                    <li>16</li>
                
                
            </footer>
        </section>

        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                  <p>
                   Finally, a quit command allows the user to signal that the editing is complete<br>
                   quit<br>
                    Exit the program.<br>
                    We make a note to ask Terry if this is a reasonable set of commands<br>
                 </p>
                 <p>
                   Questions for Terry
                 </p>
                 <ul>
                  <li>Do you (or will you ever) have a file named</li>
                  <li>Do you (or will you ever) have a file named foodlnfo</li>
                  <li>Is it OK for the program to display the date it will store for the current entry and have you verify it</li>
                  <li>Are the commands we’ve designed odd, delete, list, help, and quit sufficient for your purposes</li>
                 

                 </ul>
                 <h3 style="color: #e0214d;">Stop & Predict</h3>
                 <p>
                  <i>
                   How should users enter dates into the program?
                 </i>
                 </p>
                 <p>
                   The format of a date will be the usual month/day/yeor. We need to make clear to Terry whether a legal year should be 91 or 1991. For now, we’ll
                   assume the latter.
                 </p>

                 <h3 style="color: #e0214d;">Stop & Consider</h3>
                 <p>
                   <i>
                     Which do you prefer, two-digit years or four-digit years? Why?
                   </i>
                 </p>

                 <h3 style="color: #e0214d;">How is the history file editor organized?</h3>
                 <p>
                   We will organize the program as an instance of the “input and process until done” template, where the input step will read a command from the
                    user and the process step will execute the command. In pseudocode, the main program will appear as follows:
                 </p>
                 <p>
                   initialize;
                  repeat
                  get a cannnnand;
                  execute the connnnand;
                  until na mare commands;
                  finish up;
                 </p>
                 <p>
                   This kind of program is common enough to have a name: command interpreter. (“Interpreting” a command means executing it.)
                 </p>
                  <h3 style="color: #e0214d;">How are the history entries represented?</h3>
                  <p>
                    As we did in You Are What You Eat, we delay considering the procedural decomposition any further until we decide how to represent the collection
                    of history entries in the program.
                  </p>
                  <h3 style="color: #e0214d;">Stop & Predict</h3>
                  <p>
                    <i>
                      What are the optionsfor representing the history entries?
                    </i>
                  </p>
                  <p>
                    Currently, the history entries are stored in a disk file. One option is to retain this implementation and represent the collection internally as a Pascal file. Another option is to use an array. It is possible even likely that the representation we choose will have to be changed in some future version of the program. Designing first around the abstraction of the collection of entries, then choosing an implementation, will make changing the implementation much easier.
                  </p>
                  <h3 style="color: #e0214d;">How do we create an abstract view?</h3>
                  <p>
                    To get a comprehensive idea of the representation we need, we build “views” of the collection of history entries and the actions that will be performed on them. Views are perspectives on the actions of the program on the data objects. Generally, the least detailed view is the view the user has of the editor commands acting on the entries. The programmer’s view of the actions of the program on the data is likely to be more detailed and more precise than the users. In this case the programmer views a sequenced collection of entries that can be searched, traversed, and added to, whose size can be determined, and each of which has a date, a calorie entry, and a fat entry that can be modified. A third view is the programmer’s detailed view where the particulars of the Pascal constructs are considered.
                  </p>
                  <p>
                    In the abstract view, we are concerned with a sequence of history entries, ordered by date, most recent first. The commands can be translated into the following abstract operations:
                  </p>
                  <ul>
                    <li>Initialize the sequence.</li>
                    <li>Find the position in the sequence of the entry with a given date or the position in the sequence where an entry with that
                     date would go.</li>
                     <li>
                      Insert a new entry at a given position in the sequence
                     </li>
                     <li>
                      Delete the entry at a given position in the sequence.
                     </li>
                     <li>
                      Print all entries in the sequence
                     </li>
                     <li>
                      Print all entries between two given dates in the sequence.
                     </li>
                     </ul>
                     <p>
                       The operations are complete, yet simultaneously they provide the flexibility of implementing the sequence either as a file or as an array.
                     </p>
                     <h3 style="color: #e0214d;">Stop & Predict</h3>
                     <p>
                       <i>
                         Explain why a file or an array would work with these operations.
                       </i>
                     </p>
                     <h3 style="color: #e0214d;">What operations have we left out?</h3>
                     <p>
                       Operations for comparing dates will also be necessary. We’ll postpone thinking about them for now.
                     </p>
                     <h3 style="color: #e0214d;">How are the commands and abstract operations related?</h3>
                     <p>
                       For each of the commands, here is its action in terms of the abstract operations:
                      odd date<<br>
                      Find the position of an entry with the given date. If an entry with that date already exists, signal error; otherwise construct a new entry
                      and insert it at that position.<br>
                      delete date<br>
                      Find the position of an entry with the given date. If an entry with that date does not exist, signal error; otherwise delete the entry.
                       </p>




                
                         
            </article>
            <footer>
                <ol id="page-numbers">
                    <li>17</li>
                    <li>18</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p>
              list<br>
              Print the information in all entries,
              list date<br>
              Find the position of an entry with the given date. If an entry with that date does not already exist, signal error; otherwise print the
               information in the entry.
              list start-date end-date<br>
              Find the position of an entry whose date is the same as or preceding
              end-date. then print the information in all entries between enddote
              and start-date.
            </p>
           <h3 style="color: #e0214d;">Stop & Predict</h3>
           <p>
             For this program, we choose to implement the collection as a Pascal file. First, the size of the collection is unknown, so we cannot easily define an
              array that will accommodate all the data. Perhaps Terry will collect years of data. Second, all we want to do is put together a prototype program
              quickly, and a file will work fine for this purpose. Terry will then use it, and we will decide what needs to be improved based on his feedback.
           </p>
           <p>
             We focus now on coding the six abstract operations—initialize, find the position of an entry, insert a new entry at a given position, delete the entry
            at a given position, print all entries, and print a given range of entries using Pascal files
           </p>
            <h3 style="color: #e0214d;">Modification</h3>
            <p>
              8.14 Suppose Terry found that he frequently needed to exchange the information for one date with the information for another date.
               Describe commands that might be added to make this easy, and explain how they would be implemented in terms of the abstract 
               operations already designed.
            </p>

             <h3 style="color: #e0214d;">Analysis</h3>
             <p>
               8.15 A user might find it easier to understand a list command with only one variation rather than three. Explain how one can produce the
              output of the zero-argument and one-argument variations of the list command by using the two-argument list command.
             </p>
             <h3 style="color: #e0214d;">Reflection</h3>
             <p>
               8.16 Would it be better to have just one variation of the list command or three as we have proposed Explain.
             </p>
             <h3 style="color: #e0214d;">Analysis</h3>
             <p>
               8.17 Describe the advantages of using an array rather than a file for the collection of fat and calories.
             </p>
             <h2 style="color: #e0214d;background: lavenderblush;">Implementing the Abstract Operations</h2>
             <h3 style="color: #e0214d;">How is the ''find" operation coded?</h3>
             <p>
               All of the intended commands will use the “find” operation, so we’ll work operation coded? on that first. 4 he “find” operation will take as parameters the tile and the date whose entry is to be located. Moreover, it must return an indication of whether or not the entry is found, and the position at which it is found.Thus the procedure header will be
             </p>
             <p style="font:16px Courier New">
              procedure Find (var history: SequenceType; date: DateType;
              var found: boolean; var position: PositionType);
            </p>
            <p>
              The history file is passed as a vor parameter, both because Pascal does not allow files to be passed by value and because, should the history be stored in an array, passing it by value would result in the inefficiency of copying the array.
            </p>
             <h3 style="color: #e0214d;">Stop & Predict</h3>
 
              <p>
                <i>
                  What is the position ofan entrj in a file?
                </i>
              </p>
              <p>
                The meaning of a position is obvious with an array; its meaning for a file is much less clear, so we postpone this problem for now.
              </p>
              <h3 style="color: #e0214d;">How is a file searched?</h3>
              <p>
                Since elements of files are accessed sequentially, the “find” operation requires a linear search. The code for searching a file is similar to code for searching an array, so we can adapt the searching template from Is illegal?and Space Text. Recall that the entries in the file are stored most recent first; thus finding the position where an entry with the given date would go means finding the first entry in the file with a date that’s the same as or earlier than the given date.
              </p>      
              <p style="font:16px Courier New">
              reset (history);
              foundAtOrBefore := false;
              while not foundAtOrBefore and not eof (history) do begin
              read (history, entry);
              if entry's dote is at or before the given dote then begin
              foundAtOrBefore := true;
              end;
              end;    

            </p>
            <p>
              At the end of this loop, there are three possibilities: foundAtOrBefore is false, so Find should return failure; foundAtOrBefore is true but the entry
              date is earlier than the given date, so Find should return failure; or foundAtOrBefore is true and the entry date is identical to the given date, so Find should return success. Thus the following code must be added:
            </p>
            <p style="font:16px Courier New">
              if foundAtOrBefore then begin
              set found ro True if dare and entry.dote ore the some, and ro false otherwise;
              end else begin
              found := false;
              end;
            </p>
             <h3 style="color: #e0214d;">What happens when an entry is found?</h3>
             <p>
               When an entry is found, it may be deleted, or an entry may be added resulting in a change to the file. Either requires the file to be copied; only
              the list command requires finding an entry without modifying the file.Thus, it seems efficient to build the copying into the operation of finding
              an entry:
             </p>





                </article>
            <footer>
                <ol id="page-numbers">
                    <li>191</li>
                    <li>20</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p style="font:16px Courier New">
                  reset (history);
                  rewrite (temp)
                  foundAtOrBefore := false;
                  while not foundAtOrBefore and not eof (history) do begin
                  read (history, entry);
                  if AtOrBefore (entry.date, date) then begin
                  foundAtOrBefore := true;
                  end else begin
                  write (temp, entry);
                  end ;
                  end;
                  if foundAtOrBefore then begin
                  ser found ro true if dote and entry.dote ore the some, and to false otherwise;
                  end else begin
                  found := false;
                  end;
                </p>
                <p>
                  The history entry whose date is at or before the given date will not have been written to the temporary file when Find returns.
                </p>
                <p>
                  The temp file will need to be used by other file operations, and thus it should be a parameter. This seems undesirable, since if the sequence of
                  history entries were to be represented as an array instead of a file, it would be inappropriate to have such a parameter. An intriguing thought is to use the temp file as the position parameter. We’ll try that. Thus temp replaces position in the parameter list, and PositionType, the type of a “position” in the sequence, will be defined to be file of EntryType, just like Sequence-
                  Type.
                </p>
                <h3 style="color: #e0214d;">How is the "insert" operation coded?</h3>
                <p>
                  The “insert” operation will assume that a “find” has just been done. Its operation coded? parameters will be the history, the entry to be inserted, and the place to put it:
                </p>
                <p style="font:16px Courier New">
                  procGdure InsGrt (var history; SGquGncGTyps; Gntry: EntryTypG;
                  tamp; PositionTypa);
                </p>
                <p>
                Insertion into the history means writing it to the temporary file, copying the rest of the file to the temporary file, then copying the whole file back to the original. (We did this in You Are What You Eat) The delete operation will need to perform a similar operation, so we put the copying and
                copying back code into a separate procedure:
              </p>
              <p style="font:16px Courier New">
                writG (tamp, Gntry);
                CopyThsnCopyBack (history, tsmp);
              </p>
              <p>
                Copying is easy:
              </p>
               <p style="font:16px Courier New">
                procsdurs CopyThsnCopyBack (var original: SsqusncsType;
                tsmp: PositionTyps);
                var
                sntry: EntryTyps;
                bsgin
                while not eof (original) do begin
                read (original, entry);
                write (temp, entry);
                end;
                reset (temp);
                rewrite (original);
                while not eof (temp) do begin
                read (temp, entry);
                write (original, entry);
                end;
                end;

              </p>
              <h3 style="color: #e0214d;">How is the "delete" operation coded?</h3>
              <p>
                Delete is similar to Insert. It also assumes that Find has just been called:
              </p>
               <p style="font:16px Courier New">
                procedure Delete (var history: SequenceType; var temp: PositionType);
                begin
                CopyThenCopyBack (history, temp);
                end;
              </p>
              <h3 style="color: #e0214d;">How is the "print all entries" operation coded?</h3>
              <p>
                Printing all the history entries is another applieation of the “input and process until done” template:
              </p>
               <p style="font:16px Courier New">
                procedure PrintAll (var history: SequenceType);
                var
                entry: EntryType;
                begin
                reset (history);
                while not eof (history) do begin
                read (history, entry);
                PrintEntry (entry);
                end;
                end;
              </p>

              <h3 style="color: #e0214d;">Stop & Predict</h3>
              <p>
                <i>
                  What patterns can be recycled to create the procedure that prints the entries between two dates?
                </i>
              </p>
              <h3 style="color: #e0214d;">How is the "print all entries between two given dates"operation coded</h3>
              <p>
                The “print all entries between two given dates” operation is done after finding an entry whose date is the same as or preceding the later of the two
                dates. (Recall that the entries are arranged most recent first in the file.)Subsequent entries are read and printed until an entry preceding the earlier of the two dates is encountered. The code is almost exactly the same as the code for the first version of Find:
              </p>
               <p style="font:16px Courier New">
                procedure PrintUpTo (var history: HistoryType; date: DateType;
                position: PositionType);
                begin
                done := false;
                while not done and not eof (history) do begin
                read (history, entry);
                PrintEntry (entry);
                if enrry dare is before rhe earlier dare then begin
                done := true;
                end;
                end;
                end;

              </p>



              </article>
            <footer>
                <ol id="page-numbers">
                    <li>21</li>
                    <li>22</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <p>
               Note that a position parameter is necessary to be consistent with the other procedures that follow a call to Find.
             </p>
             <h3 style="color: #e0214d;">Stop & Help</h3>
             <p>
               <i>
                 Find the bug in the above code.
               </i>
             </p>
             <h3 style="color: #e0214d;">How is the "initialize"operation coded?</h3>
             <p>
               Last is the “initialize” operation. Since every operation that reads through the file starting at the beginning does its own reset, no initialization is necessary. Thus the corresponding procedure is empty:
             </p>
             <p style="font:16px Courier New">
              procedure Initialize (var history: HistoryType);
              begin
              end;
            </p>
            <h3 style="color: #e0214d;">Stop & Predict</h3>
            <p>
              <i>
                What sort offunctions are bestfor comparing the dates?
              </i>
            </p>
            <h3 style="color: #e0214d;">What about the code that manipulates dates?</h3>
            <p>
              Find and PrintUpTo both involve comparison of two dates. We will use two boolean functions: Precedes and SonneDote. Recall that a date has three
              components, a year, a month, and a day. A date stored in date1 is earlier than a date stored in dQte2 if dotei’s year is earlier than date2’s, if the
              years are the same and date1’s month is earlier than date2’s, or if the years and months are the same and dotei’s day is earlier than date2’s. Two
              dates are the same if all their components are equal. Here’s the code for the two functions:
            </p>
             <p style="font:16px Courier New">
            function Precedes (datel, date2: DateType): boolean;
            begin
            if datel.year < date2.year then begin
            Precedes ;= true;
            end else if datel.year > date2.year then begin
            Precedes := false;
            end else if datel.month < date2.month then begin
            Precedes := true;
            end else if datel.month > date2.month then begin
            Precedes := false;
            end else begin
            Precedes := datel.day < date2.day;
            end;
            end;
            function SameDate (datel, date2: Dateiype): boolean;
            begin
            SameDate := (datel.year = date2.year)
            and (datel.month = date2.month)
            and (datel.day = date2.day);
            end;
            </p>
            <p>
              (Standard Pascal does not allow comparison of entire records.)
            </p>
             <h3 style="color: #e0214d;">How can the code be tested?</h3>
             <p>
               The routines written so far can be combined with a driver program and tested. We do this now.
             </p>
             <p>
               The first development step is to test the file printing routines. Once working, they provide a way to test the other code. ITe test data for the file
                handling code is similar to what would be used with an array: check the middle values along with the boundary values. Here, we are interested in
                values not in the file as well as those in the file, so we test PrintUpTo with the latest and earliest dates in the file as well as dates following the latest date and preeeding the earliest date. A diagram representing these test cases appears below.
             </p>
              <h3 style="color: #e0214d;">What bugs are encountered?</h3>
              <p>
                A bug arises from a mismatch between the program that created the file and the driver program used for testing. In the driver program, MonfhType
                is declared as integer to simplify input of test values, while in the creation program MonrhType is declared as an enumerated type. Most Pascal environments do no error checking at all for input from non-text files, assuming that they will be read in the same way they were written. Any source of inconsistency will cause errors. This may be regarded as a disadvantage of this representation.
              </p>
              <p>
                Testing also reveals a bug in PrintUpTo; the symptom is that one too many entries are getting printed. The problem turns out to be that the first entry outside the requested range was printed before it was checked. We rearrange the code to put the call to PrinfEntry inside an if statement, but then we get the comparison backward. One more test run reveals this bug and leads to the code in the Pascal Code section.
              </p>
              <p>
                Find is next to be tested, since the other operations use it. Test values are similar to those used with PrintUpTo. Finally all the other operations are tested; again we focus mainly on boundary values.
              </p>
              <p>
                While testing and analyzing the code just written, we realize that the decision to store the file in reverse order introduces an extra level of confusion. We have to worry not only about the search test being off by one entry, but also about the direction of the error. We resolve to be especially careful in checking for errors in operations that search the file, and to look for an opportunity to simplify the code in future revisions of the program.
              </p>
              <h3 style="color: #e0214d;">Analysis</h3>
              <p>
                8.18 Should Find always search the entire file? Why or why not?
              </p>
              <h3 style="color: #e0214d;">Modification</h3>
              <p>
                8.19 Modify the Initialize procedure to check that dates of file entries are ordered from most recent to least recent and to print a warning
                 message if they are not.
              </p>




            </article>
            <footer>
                <ol id="page-numbers">
                    <li>23</li>
                    <li>24</li>
                </ol>
            </footer>
        </section>
                 <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
            <h3 style="color: #e0214d;">Modification</h3>
            <p>
              8.20 Modify the Initialize procedure to check that there are no duplicate dates in history entries and to print a warning message if there are
              entries with duplicate dates.
            </p>
            <h3 style="color: #e0214d;">Reflection</h3>
            <p>
              8.21 List bugs that programmers should anticipate when writing routines that process files.
            </p>
             <h2 style="color: #e0214d;background: lavenderblush;">Designing and Developing the Remainder of the History Editor</h2>
              <h3 style="color: #e0214d;">What remains to be designed?</h3>
              <p>
                Now that the routines to manipulate the history data structure are designed and tested, we can proceed to the main program and the command
                scanner.<br>
                Recall that we decomposed the main program as follows:<br>
                initialize;<br>
                repeat<br>
                get a commond;<br>
                execute the connnnand;<br>
                until no more commonds;<br>
                finish up;<br>
                Hidden in that decomposition are such details as reading characters from the input, isolating and translating commands and date arguments, and
                checking for errors.<br>
              </p>
              <h3 style="color: #e0214d;">What should the "get a command" step do?</h3>
              <p>
                Getting a command is an ambiguous step. How much work should the "get a command” step do? Here are two possibilities at opposite ends of the spectrum.<br>
                Get just the first word of the command: Read characters until the first word of the command is isolated, then check that word. Once the command word
                is recognized, subsequent input and processing is handled in the “execute
                the command” step.<br><br>
                Get a complete legal command: Read the complete command including its arguments, check it for errors, and translate it into an internal form. The
                “execute the command” step then performs only the appropriate history file operations.
              </p>
              <h3 style="color: #e0214d;">Stop & Predict</h3>
              <p>
                <i>
                  What are some alternatives for the ''get a command'' step between these extremes?
                </i>
              </p>
              <h3 style="color: #e0214d;">What worked before?</h3>
              <p>
                In is it Legal?we used the “read one, process one” template for input and found it advantageous to read a whole line of input before processing.
                This suggests a third possibility, which also eliminates checks for end-ofline after the input step.
              </p>
              <p>
                Get the line, process the command word: Read an entire line, then isolate the first word on the line and make sure it specifies a legal command. Subsequent isolation of arguments on the line is handled in the “execute the command” step.<br>
                This seems better than the “get just the command word” alternative.
              </p>
              <h3 style="color: #e0214d;">How do we select on alternative?</h3>
              <p>
                The choice between “get the line, process the comrnand word” and “get on alternative? a complete legal command” consists mainly in deciding how much to analyze the commands in the “get a command” code. The goal is to make the code clear and to avoid unnecessary repetition.
              </p>
              <p>
                The decision will depend on the form of the commands. Similar commands can be analyzed by the same code; commands that differ in form
                must be analyzed separately.
              </p>
              <p>
                In addition, the code for command execution will be clearer if error checking is done when the command is read. Error checks in the command 
                execution routines can obscure the processing performed by the routines.However, if error checks and command interpretation are similar, they are
                best combined in the command execution step.
              </p>
              <p>
                The choice of how much processing to do in the “get a command” step arises in the design of any command interpreter. To decide for this
                 program, we gather some more information about the commands.
              </p>
              <h3 style="color: #e0214d;">Stop & Predict</h3>
              <p>
                <i>
                  What common command errors will need to be checked?
                </i>
              </p>
              <h3 style="color: #e0214d;">What errors will the program check?</h3>
              <p>
                To determine where to put the error-checking routines, we make a list of the possible errors in the arguments to the various commands.
              </p>
              <p>
                list                     too many arguments (3 or more) are specified one of the arguments isn’t a date there is no history entry with the given 
                                          date there is no history entry in the given range of dates<br>
             </p>
             <p>
                odd                       too many arguments (2 or more) are specified too few arguments (0) are specified the argument isn’t a date a history
                                          entry with the given date already exists <br>
             </p>
             <p>                             
                delete                    too many arguments (2 or more) are specified too few arguments (0) are specified the argument isn’t a date no history 
                                          entry with the given date exists<br>
              </p>
              <p>                            
                help                      no errors are possible<br>
              </p>
              <p>
                quit                      no errors are possible<br>
              </p>
               <h3 style="color: #e0214d;">What are the pros and cons of each decomposition?</h3>
               <p>
                 Examining the possible errors does not completely clarify what the “get a command” step should do. The number of arguments varies with the
                  command, arguing against error checking in the “get a command” step.
               </p>
              








            </article>
            <footer>
                <ol id="page-numbers">
                    <li>25</li>
                    <li>26</li>
                </ol>
            </footer>
        </section>

         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p>
               On the other hand, all the arguments are dates, so it makes sense to have a single routine to check that each date argument is legal.<br>
                The choice is between “get the line, process the command word” and “get a complete legal command.” We decide to design both solutions and
                compare them.
             </p>
              <h3 style="color: #e0214d;">Analysis</h3>
              <p>
                8.22 In this design the output requested by the user is deduced by examining the arguments to the list command. Instead, one might provide
                several different list commands such as listAll, listSome, and listOne.Explain the advantages and disadvantages of each approach
              </p>
              <h3 style="color: #e0214d;">Reflection</h3>
              <p>
                8.23 Given the nature of novice computer users, what kinds of help besides a list of legal commands might be added to the program?
                 Justify each suggestion.
                
              </p>

              <h3 style="color: #e0214d;">Analysis</h3>
              <p>
                8.24 Provide a pseudocode description of an interactive interface for this program that asks the user for a date only if the command requires
               date information. What are the advantages of this approach?
              </p>
               <h2 style="color: #e0214d;background: lavenderblush;">The "Get the Line, Process the Command Word" Design</h2>
               <h3 style="color: #e0214d;">What will Get Command and Execute Command do?</h3>
               <p>
                 In the “get the line, process the command word” design, the GetCommand procedure will start by reading a line. It will then isolate the first
                word in the line, make sure it’s a command, and return. Depending on the command, ExecuteCommond will call one of the specialized execution
                procedures ExecuteList, Executelnsert, ExecuteDelete, ExecuteHelp, or ExecuteQuit.Some of these will isolate the following word(s) on the line,
                 convert them to dates, and apply the appropriate history file operations.
               </p>
               <h3 style="color: #e0214d;">How will GetCommand and ExecuteCommand communicate?</h3>
               <p>
                 GetCommond and ExecuteCommond both need to access the line containing the command. Thus the line will need to be either a parameter to both
                or a variable global to both. To make clear just what is getting communicated to what, we will make the line a parameter to both procedures.
               </p>
               <p>
                 ExecuteCommond will need to know the position in the line at which to start looking for arguments. This might also be passed as a parameter.
                  Rather than store it separately from the line, however, we will combine it with the line in a record.
               </p>

               <h3 style="color: #e0214d;">Stop & Help</h3>
               <p>
                 <i>
                   Write a declaration for the record that will hold the line and the position.
                 </i>
               </p>
               <h3 style="color: #e0214d;">How will ExecuteCommand work?</h3>
               <p>
                 ExecuteCommond conceptually is an application of the “select from alternatives” template. In earlier case studies we used a cose statement to
                  select alternatives. Pascal does not allow the use of strings as cose selectors. One solution is to define an enumerated type with one element for each command, since members of an enumerated type can be used as case selectors. GetCorrmnond can then translate the isolated command word into a member of that type before returning.
               </p>

               <h3 style="color: #e0214d;">What are the headers for these procedures?</h3>
               <p>
                 This solution leads to the following type definitions and procedure headers for GefCommond and ExecufeCommond:
               </p>




             
               <p style="font:16px Courier New">
                type
                LineType = record
                chars; array [1..MAXLENGTH] of char;
                length: integer;
                position: integer;
                end;
                ConmandType = (LISTCMD, ADDCMD, DELETECMD, HELPCMD, QUITCMD, UNKNOWN);
                procedure GetCommand (var line: LineType; var command: CommandType);
                procedure ExecuteCommand (var line: LineType; command; CommandType;
                var history: SequenceType; var status: StatusType);
              </p>
               
                
              <h3 style="color: #e0214d;">What is a consistent design for the Get... procedures?</h3>
              <p>
                Note that there is a lot of “getting” going on: “getting” a line, “getting” a command, “getting” an argument, and so on. It makes sense to have the
                corresponding procedures be as similar as possible. Each should have a parameter of the type being “gotten.”
              </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  Create informative namesfor the parameters that each procedure ''gets. ”
                </i>
              </p>

              <h3 style="color: #e0214d;">What about illegal commands?</h3>
              <p>
                Suppose that there is an error in the user’s command. Each “get” routine must have a way of indicating to its caller that there was nothing to get or that the thing being gotten was of the wrong type.
              </p>
              <p>
                In Is It Legal? a parameter of type boolean was used to indicate an error.In this situation, there are two types of error the program should indicate:
              </p>
              <ul>
                <li>
                  error because there is nothing left on the line or in the input
                </li>
                <li>
                  error because there is something on the line or in the input, but it is of the wrong type
                </li>
              </ul>
               <h3 style="color: #e0214d;">Stop & Predict</h3>
               <p>
                 <i>
                  List the specific errors that the program might detect on the line.
                   
                 </i>

               </p>
               <h3 style="color: #e0214d;">How should the errors be indicated?</h3>
               <p>
                 To indicate the status of the processing of the line we provide an extra parameter to each of the Gef... routines. We define an enumerated type
                whose members are status values. They represent errors detectable either in GefCommond or ExecufeCommond:
               </p>
               <p>
                 SUCCESS               The command could be completed successfully.<br>
                 NOINPUT               GetLine found no line to return (it encountered end-offile on input).<br>
                 LINETOOLONG           GetLine found too many characters to read on the line.<br>
                 </p>
              





               




            </article>
            <footer>
                <ol id="page-numbers">
                    <li>27</li>
                    <li>28</li>
                </ol>
            </footer>
        </section>

         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p>
                NOWORD                  GetWord found no further things on the line to read.<br>
                WORDTOOLONG             GetWord found a word longer than it had room for.<br>
                NOCOMMAND               GetCommond found a blank line.<br>
                BADCOMMAND              The first word on the line was not a legal command.<br>
                NODATE                   The last thing on the line has been read.<br>
                TOOAAANYDATE5           Too many arguments were specified on the command line.<br> 
                BADDATE                 An argument isn’t a correctly formatted date.<br>
                ALREADYTHERE             A request to add an entry duplicated an existing date.<br>
                NOHHERE                  A delete or list request specified a nonexistent entry.<br>
                EMPTYRANGE               A list request specified a range of dates that contained no history entries.<br>    
               </p>
               <p>
                 Here are revisions to the type definitions and procedure headers provided so far:
               </p>
                <p style="font:16px Courier New">
                  type
                  StatusType = (SUCCESS, NOINPUT, LINETOOLONG, NOWORD, WORDTOOLONG,
                  NOCOMMAND, BADCOMMAND, NODATE, TOOMANYDATES, BADDATE,
                  ALREADYTHERE, NOTTHERE, EMPTYRANGE);
                  procedure GetCommand (var line: LineType; var command: CommandType;
                  var status: StatusType);

                </p>
               <h3 style="color: #e0214d;">How is GetCommond coded?</h3>
               <p>
                 The code for GetCommond is now straightforward
               </p>
                <p style="font:16px Courier New">
                  procedure GetGommand (var line: LineType; var command: CommandType;
                  var status: StatusType);
                  begin
                  write('COMMAND? ');
                  GetLine (line, status);
                  if status = SUCCESS then begin
                  GetCmdWord (line, command, status);
                  end;
                  end;

                </p>

                <p>
                  The GetLine and GefCmdWord procedures are similar to procedures used in Is It Legal? and Space Text.
                </p> 
                <p style="font:16px Courier New">
                  procedure GetLine (var line: LineType; var status: StatusType);
                  var
                  ch: char;
                  begin
                  status := SUCCESS;
                  if eof then begin
                  status := NOINPUT;
                  end else begin
                  line.length := 0;
                  line.position := 1;
                  while not eoln do begin
                  read (ch);
                  if line.length = MAXLINELEN then begin

                  </p>
                    <p style="font:16px Courier New">

                  status LINETOOLONG;
                  end else begin
                  line.length := line.length + 1;
                  line.chars[line.length] := ch;
                  end;
                  end;
                  readln;
                  end ;
                  end;
                  procedure GetCmdWord (var line: LineType; var command: GommandType;
                  var status: StatusType);
                  var
                  word: WordType;
                  begin
                  status := SUCCESS;
                  command := UNKNOWN;
                  GetWord (line, word, status);
                  if status = NOWORD then begin
                  status := NOCOMMAND;
                  end else if word = LISTWORD then begin
                  command := LISTCMD;
                  end else if word = ADDWORD then begin
                  command := ADDCMD;
                  end else if word = DELETEWORD then begin
                  command := DELETECMD;
                  end else if word = HELPWORD then begin
                  command := HELPCMD;
                  end else if word = QUITWORD then begin
                  command := QUITCMD;
                  end else begin
                  status := BADCOMMAND;
                  end;
                  end;                                     
                  </p>
                   <h3 style="color: #e0214d;">Stop & Help</h3>
                   <p>
                     <i>
                       Write the GetWord procedure. Its arguments are the line, a packed array of characters, anda status. It will return the next wordfrom the line in the array and update the line position appropriately.
                     </i>
                   </p>
                    <h3 style="color: #e0214d;">How does the design of GetCommond affect the main program?</h3>
                    <p>
                      GetCommand returns either with status = SUCCESS and command containing a translated command or with status indicating some error 
                      and command = UNKNOWN. The next question is where to handle the latter case.If status does not equal SUCCESS, code to print an error message could be added to the end of GetCommand. Or the main program could contain this code. Or ExecuteCommand might be written to handle an unknown command as well as all the legal commands.
                    </p>
                    <p>
                    A complicating factor is that one non-SUCCESS value for status, namely NOINPUT, represents an alternative way to quit the program. Thus either
                    the main program will have to examine the contents of status, or GetCommand will have to return a value of QUITCMD in this case.
                  </p>

                </article>
            <footer>
                <ol id="page-numbers">
                    <li>29</li>
                    <li>30</li>
                </ol>
            </footer>
        </section>

         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <p>
               Somewhat arbitrarily, we choose to complicate both GetCommand and the main program slightly by adding status checks to each. The revised code
                follows.
              </p>
               <p style="font:16px Courier New">
                procedure GetCommand (var line: LineType; var command: CommandType;
                var status: StatusType);
                begin
                write('COMMAND? ');
                GetLine(line, status);
                if status = NOINPUT then begin
                command := QUITCMD;
                status := SUCCESS;
                end else if status = SUCCESS then begin
                GetCmdWord (line, comimand, status) ;
                end;
                end;
                {*** main program ***}
                begin
                Initialize(history);
                done := false;
                repeat
                GetCommand(line, command, status);
                if status = SUCCESS then begin
                ExecuteCommand(line, command, history, status);
                end;
                if status <> SUCCESS then begin
                PrintErrorMsg(status);
                end;
                until command = QUITCMD;
                end.
                
              </p>
              <p>
                The main program uses a PrintErrorMsg procedure to print an error message.It is useful to print all error messages in one place, just in case we wish in a future revision to change their format or keep track of which errors are most commonly made by users.
              </p>
              <h3 style="color: #e0214d;">How is ExecuteCommand designed?</h3>
              <p>
                Given a legal command, ExecuteCommand merely needs to decide which command it is and then execute it. A straightforward decomposition is to
                 have a different execution procedure for each command. Deciding which of the procedures to call can be done in a case statement:
              </p>
              <p style="font:16px Courier New">

                case command of
                LISTCMD: ExecuteList (line, history, status);
                ADDCMD: ExecuteAdd (line, history, status);
                DELETECMD: ExecuteDelete (line, history, status);
                HELPCMD: ExecuteHelp (line, history, status);
                QUITCMD: ExecuteQuit (line, history, status);
                end;
              </p>
              <p>
                ExecuteHelp and ExecuteQuit don’t really need any arguments, but we code them the same as the other execution procedures for consistency.
              </p>
               <h3 style="color: #e0214d;">How is ExecufeLisr designed?</h3>
               <p>
                 ExecufeList is the hardest of the execution procedures, since it may take 0,1, or 2 arguments. Thus we attack it first. It reads dates from the commandline, then performs the appropriate operation on the history file.
               </p>
               <p>
                 Reading the command arguments will be done using a GetDofe procedure whose parameters are the line, a date to be returned, and a status. Date 
                 arguments will be counted and stored in an array of size 2. The process is very similar to that of reading a line, as shown in the table below.
               </p>
               <P>
                 The main difference is that eoln rather than read is called to see if there are no more characters, but GetDATe is called to find that there are no more dates. Here’s the code:
               </P>
               <p style="font:16px Courier New">
                procedure ExecuteList (var line: LineType; var history: SequenceType;
                var status: StatusType);
                var
                dates: array [1..2] of DateType;
                tempDate: DateType;
                numDates: integer;
                done, found: boolean;
                position: PositionType;
                entry: EntryType;
                begin
                done := false;
                numDates := 0;
                while not done do begin
                GetDate (line, tempDate, status);
                if status <> SUCCESS then begin
                done := true;
                end else if numDates = 2 then begin
                status := TOOMANYDATES;
                done := true;
                end else begin
                numDates := numDates + 1;
                dates [numDates] := tempDate;
                end;
                end;
                if status = NODATE then begin
                status := SUCCESS;
                case numDates of
                0 : PrintAll (history
              </p>


            
            </article>
            <footer>
                <ol id="page-numbers">
                    <li>31</li>
                    <li>32</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <p style="font:16px Courier New">
              1; begin
              Find(history, dates[l], found, entry, position);
              if found then begin
              PrintEntry (entry);
              end else begin
              status := NOTTHERE;
              end;
              end;
              2: begin
              Find(history, dates[2], found, entry, position);
              if not (AtOrBefore(entry.date, dates[2])
              and AtOrBefore(dates[1], entry.date)) then begin
              status := EMPTYRANGE;
              end else begin
              PrintEntry (entry);
              PrintUpTo(history, dates[1]);
              end;
              end;
              end;
              end;
              end
            </p>
            <h3 style="color: #e0214d;">How is ExecuteAdd coded</h3>
            <p>
            ExecuteAdd will be easier to code, since the odd command takes exactly one date argument. The argument will be retrieved from the line, the line
            will be checked to make sure no more dates have been provided, the code from the revised You Are What You Rat WW be inserted to collect a day’s
            data from the user, and then the appropriate history file operation will be applied. Here’s the code:
          </p>
           <p style="font:16px Courier New">
            procedure ExecuteAdd (var line: LineType; var status: StatusType);
            var
            date, tempDate: DateType;
            entry: EntryType ;
            found: boolean; position: PositionType;
            begin
            GetDate (line, date, status);
            if status = SUCCESS then begin
            GetDate (line, tempDate, status);
            if status = SUCCESS then begin
            status := TOOMANYDATES;
            end else if status = NODATE then begin
            status := SUCCESS;
            end;
            end;
            if status = SUCCESS then begin
            Eind(history, date, found, entry, position);
            if found then begin
            status := ALREADYTHERE;
            end else begin
            entry.date := date;
            ReadEntry (entry);
            Insert(history, entry, position);
            end;
            end;
            end;
          </p>
           <h3 style="color: #e0214d;">How are the remaining Execute routines coded?</h3>
           <p>
             ExecuteDelete is even simpler than Executelnsert. The coding is straightforward.
           </p>
           <h3 style="color: #e0214d;">Stop & Help</h3>
           <p>
             <i>
               Code the ExecuteDelete procedure
             </i>
           </p>
           <p>
             ExecuteHelp merely prints a helpful message about all the commands. ExecuteQuit need do nothing, but perhaps a message saying something like
             “Exiting history file editor” would be
           </p>
           <h3 style="color: #e0214d;">How is the GetDate procedure designed?</h3>
           <p>
             All that’s left is the GetDote procedure. Recall that the format of a date is month/doy/yeor. GetDote must retrieve and analyze the components of the
            date from the line. For consistency with GetCmdWord, GetDote will first call GetWord to isolate the next argument from the line, and then work
            with the isolated word.
           </p>
            <h3 style="color: #e0214d;">What are possible errors in a d ate?</h3>
            <p>
              To aid in decomposing GetDate, it will help to list all the possible errorsthat can appear in a nonempty date
            </p>
            <ul>
              <li>
                It doesn’t start with digits
              </li>
              <li>
                It starts with digits that represent a value less than 1 or greater than 12.
              </li>
              <li>
             The digits aren’t followed by a slash.
           </li>
           <li>
             The slash isn’t followed by digits.
           </li>
           <li>
             The digits following the slash represent a value less than 1 or greater
            than the number of days in the month.
          </li>
          <li>
             The digits are followed by something other than a slash.
           </li>
           <li>
             The second slash isn’t followed by digits.
           </li>
           <li>
             The remaining digits represent a value that isn’t a legal year.
           </li>
           <li>
             A year is followed by anything other than the end of the word.
            </li>
            </ul>
            <h3 style="color: #e0214d;">How is GetDote decomposed?</h3>
            <p>
              We could process the date word with a sequence of character accesses and tests, but this would be clumsy. Another option is to provide procedures
              to get an integer and a slash, analogous to the other Get... procedures. This leads to the following code:
            </p>
            <p style="font:16px Courier New">
              GetInteger (word, int, status);
              if status = NOINT then begin
              status := BADDATE;
              end else if not (int in [1..12]) then begin
              status := BADDATE;
              end else begin
              GetSlash (word, status);
              if status = NOSLASH then begin
              status := BhDDATE;
              end else begin
              GetInteger (word, int, status);
              if status = NOINT then begin
              status := BADDATE;
              end else begin

            </p>




            </article>
            <footer>
                <ol id="page-numbers">
                    <li>33</li>
                    <li>34</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  Complete the codejust outlined.
                </i>
              </p>
              <p>
                This is clumsy. Extra tests could reduce the nesting of the code as follows:
              </p>
              <p style="font:16px Courier New">
                Getinteger (word, int, status);
                if status = NOINT then begin
                status := BADDATE;
                end else if not (int in [1..12]) then begin
                status := BTVDDATE;
                end;
                if status = SUCCESS then begin
                GetSlash (word, status);
                if status = NOSLASH then begin
                status := BADDATE;
                end;
                end;
                if status = SUCCESS then begin
              </p>
              <h3 style="color: #e0214d;">Stop & Help</h3>
              <p>
                <i>
                  Complete the code above.
                </i>
              </p>

              <p>
                This is still clumsy. Some sort of loop is preferable. We try a state-based approach similar to that used in Is ItLegal? but it is too complicated. Sometimes a brute-force approach is best of all, despite its inelegance; this seems to be such a situation. The following code, in which checks of form (for example, that the month has 1 or 2 digits) precede checks for content (for example, that the month value is at most 12), results.
              </p>
              <p style="font:16px Courier New">
                procedure GetDate (var line: LineType; var date: DateType;
                var status: StatusType);
                var
                word: WordType;
                index: integer;
                month, day, year: integer;
                begin
                GetWord(line, word, status);
                if status = NOWORD then begin
                status := NODATE;
                end;
                if status = SUCCESS then begin
                index := 1;
                GetOneOrTwoDigits(word, index, month, status);
                end;
                if status = SUCCESS then begin
                GetSeparator(word, index, status);
                end;
                if status = SUCCESS then begin
                GetOneOrTwoDigits(word, index, day, status);
                end;
                if status = SUCCESS then begin
                GetSeparator(word, index, status);
                end;
                if status = SUCCESS then begin
                GetFourDigits(word, index, year, status);
                end;
                if status = SUCCESS then begin
                CheckNoMore(word, index, status);
                end;
                if status = SUCCESS then begin
                if not LegalDate(month, day, year) then begin
                status := BADDATE;
                end else begin
                date.month := MonthEquiv(month);
                date.day := day;
                date.year := year;
                end;
                end;
                end;
              </p>
              <p>
                Each Get... procedure above checks for the specified eharacters, increments index if it finds them, and stores an error value in status if it does not.For example, here’s the code for GetOneOrTwoDigits:
              </p>
               <p style="font:16px Courier New">
                if IsDigit(word[index]) and not IsDigit(word[index + 1]) then begin
                n := DigitValue(word[index]);
                index := index + 1;
                end else if IsDigit(word[index]) and IsDigit(word[index + 1]) then begin
                n := 10 * DigitValue(word[index]) + DigitValue(word[index + 1]);
                index := index + 2;
                end else begin
                status : = BTIDNUM;
                end;
              </p>
              <p>
                Not pretty, but it works. We also invent several new status values, and add corresponding error messages to PrintErrorMsg:
              </p>
              <p>
                DADNUM                    Either the month, the day, or the year is incorrectly formatted.
                DAD5EP                    A slash (separator) was not found where expected.
                EXTRAJUNK                 There were nonblank characters after the year.
              </p>
              <p>
                That completes the program.
              </p>
               <h3 style="color: #e0214d;">Stop & Help</h3>
               <p>
               Produce the call diagramfor the program just completed.
             </p>
               <h3 style="color: #e0214d;">How is all this code tested and debugged?</h3>
               <p>
                 The file-manipulating routines were tested previously, so what remains are the procedures to get a date and execute commands. We test GetDote
                separately (together with subprograms IsDigit, DigitValue, GetWord, GetLine, WriteInDote, LeopYeor, LeopDoy, NunnberOfDoysIn, and the proeedures
                GetDote calls directly) with a program that repeatedly reads a date and prints it. With test data, we make sure that boundary dates at the start
                and end of months are handled correctly and that values with one too many or one too few digits are detected.
               </p>
               <p>
                 Finally, we test the remainder of the program. Unlike code in earlier ease studies, this program does not include a DEBUGGING switeh, since we 
                 feel that the list command provides as much information as necessary to detect bugs.
               </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>35</li>
                    <li>36</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <h3 style="color: #e0214d;">Application</h3>
             <p>
               8.25 Add a command called Copy to the “get a line, process a command word” version that copies the fat and calorie information from the
                    history file entry for one date as the fat and calorie information for another date. Change the program as little as possible.
             </p>
             <h3 style="color: #e0214d;">Analysis</h3>
             <p>
               8.26 Suppose a boolean function NoMoreWords had been written that returned true exactly where there were no more words on its line 
               argument. In which routines should NoMoreWords be called?
             </p>
             <h3 style="color: #e0214d;">Modification</h3>
             <p>
               8.27 Write the NoMoreWords function, and modify the program to call it where appropriate.
             </p>
             <h3 style="color: #e0214d;">Reflection</h3>
             <p>
               8.28 Compare the brute-force approach to the attempt at elegance in processing dates. What features of a date make the brute-force 
               approach reasonable?               
             </p>
             <h3 style="color: #e0214d;">Testing</h3>
             <p>
                8.29 Design a collection of test cases for GetDate. Describe why each is necessary and explain why this set of cases will adequately test the
                     routine.
             </p>
             <h2 style="color: #e0214d;background: lavenderblush;">The "Get a Complete Legal Command" Design</h2>
             <h3 style="color: #e0214d;">What are the differences between the two designs?</h3>
             <p>
               Having implemented the “get a line, process the command word” version of this program, it is easy to convert the design to “get a complete legal
              command.” The only real difference is that dates must be isolated and analyzed in the GetCommond procedure rather than in the ExecuteCommand procedure. There will be several changes in details, however.
             </p>
             <h3 style="color: #e0214d;">Stop & Predict</h3>
             <p>
               <i>
                 What subprograms will need to be modified?
               </i>
             </p>
             <h3 style="color: #e0214d;">How will the main program change?</h3>
             <p>
               First, the main program will change. ExecuteCommand will no longer need the line as an argument, since GetCommond will have completely processed the line. (It will still need a status argument, since there are still errors to detect after the command is read.) The command will now 
               include the arguments as well as the command word; thus a new definition is provided for CommondType: 
             </p>
               <p style="font:16px Courier New">
                CmdWordType = (LISTCMD, UNKNOWN); {the old CommandType}
                CommandType = record
                cmdWord: CmdWordType;
                numArgs: integer;
                args: array [1..2] of DateType;
                end;


              </p>
              <p>
                Here’s the rewritten main program:
              </p>
               <p style="font:16px Courier New">
                Initialize(history);
                done := false;
                repeat
                GetCorTtmand(line, command, status) ;
                if status = SUCCESS then begin
                ExecuteCommand(command, history, status);
                end;
                if status <> SUCCESS then begin
                PrintErrorMsg(status);
                end;
                until command.cmdWord = QUITCMD
              </p>
               <h3 style="color: #e0214d;">How will the Execute procedures change?</h3>
               <p>
                 These changes are propagated to the command-handling routines. Instead of taking a line as a first argument, they take a command. They no
                  longer “get” the arguments themselves; each routine is cut roughly in half as a result. Here, for example, is ExecufeAdd:
               </p>
               <p style="font:16px Courier New">
                procedure ExecuteAdd (var command: CommandType;
                var history: SequenceType;
                var status: StatusType);
                var
                found: boolean;
                entry: EntryType;
                position: PositionType;
                begin
                Find(history, command.args[1], found, entry, position);
                if found then begin
                status := ALREADYTHERE;
                end else begin
                entry.date := command.args[1];
                ReadEntry(entry);
                Insert(history, entry, position);
                end;
                end;


              </p>
              <p>
                None of the history file operations changes.
              </p>
              <h3 style="color: #e0214d;">How will the new GetCommand be organized?</h3>
              <p>
                To design the new GetCommand, we repeat an approach taken in Is It Legal?it applies successively more stringent checks to the contents of the
                line. The checks follow.
              </p>
              <ul>
                <li>
                  Has a nonempty line been entered?
                </li>
                <li>
                  Does the line contain at least one word and at most three?
                </li>
                <li>
                  Is the first word a command word, and is the number of words that remain consistent with that command?
                </li>
                <li>
                  Do the remaining words represent dates?
                </li>

              </ul>





            </article>
            <footer>
                <ol id="page-numbers">
                    <li>37</li>
                    <li>38</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <p>
               The diagram below represents how these cheeks focus increasingly on the line contents.
             </p>
             <p>
               Assuming that each check is done in a separate procedure, we code GetCommand as shown below.
             </p>
              <p style="font:16px Courier New">
                procedure GetCommand (var line: LineType; var command: CommandType;
                var status: StatusType);
                var
                words: WordArrayType;
                begin
                write('COMMAND? ');
                GetLine(line, status);
                if status = NOINPUT then begin
                command.cmdWord := QUITCMD;
                command. niomArgs : = 0 ;
                status := SUCCESS;
                end else begin
                if status = SUCCESS then begin
                GetWords(line, words, status);
                end;
                if status = SUCCESS then begin
                ConvertToCommand(words, command, status);
                end;
                if status = SUCCESS then begin
                ConvertToArgs(words, command, status);
                end;
                end;
                end;
                </p>

                <p>
                  The type WordArrayType represents an array of the words on the command line. Patterning it on LineType, we supply the following definitions:
                </p>           
                <p style="font:16px Courier New">
                  const
                  MAXCMDLEN = 3;
                  type
                  WordArrayType = record
                  length: integer;
                  words: array [1..MAXCMDLEN] of WordType;
                  end; {WordType was defined in rhe earlier version of rhe program .}

                </p>
                 <h3 style="color: #e0214d;">How is the command word analyzed?</h3>
                 <p>
                   GetLine is unchanged. GetWords is coded to resemble GetLine and the argument-reading code from the earlier version of the history editor. ConvertToCommand is patterned on GetCmdWord from the earlier version; it checks in addition that the number of arguments matches the command,
                   as follows:
                 </p>
                  <p style="font:16px Courier New">
                    procedure ConvertToCommand (var words: WordArrayType;
                    var command: CommandType; var status: StatusType);
                    begin
                    status := SUCCESS;
                    command.cmdWord := UNKNOWN;
                    if words.length = 0 then begin
                    status := NOCOMMAND;
                    end else if words.words[1] = LISTWORD then begin
                    command.cmdWord := LISTCMD;
                    command.numArgs := words.length - 1;
                    end else if words.words[1] = ADDWORD then begin
                    command.cmdWord := ADDCMD;
                    if words.length < 2 then begin
                    status := NODATE;
                    end else if words.length > 2 then begin
                    status := TOOMANYDATES;
                    end else begin
                    command.numArgs := 1;
                    end;
                    end else if words.words[1] = DELETEWORD then begin
                    command.cmdWord := DELETECMD;
                    if words.length < 2 then begin
                    status := NODATE;
                    end else if words.length > 2 then begin
                    status := TOOMANYDATES;
                    end else begin
                    command.numArgs := 1;
                    end;
                    end else if words.words[1] = HELPWORD then begin _
                    command.cmdWord := HELPCMD;
                    command.numArgs := 0;
                    end else if words.words[1] = QUITWORD then begin
                    command.cmdWord := QUITCMD;
                    command.numArgs := 0;
                    end else begin
                    status := BADCOMMAND;
                    end;
                    end;

                  </p>
                   <h3 style="color: #e0214d;">How are the arguments analyzed?</h3>
                   <p>
                     ConvertToArgs converts the arguments to dates. It calls a procedure ConvertToDate once for each argument. ConveitToDofe is essentially GetDate
                     from the earlier version without the initial call to GetWord.
                   </p>
                    <h3 style="color: #e0214d;">Which version is better?</h3>
                    <p>
                      The subprograms that are different in the two versions appear in the Pascal Code section. The “get a complete legal command” version is slightly longer than the “get a line, process the command word” version. It should,however, be much easier to add a command to the “get a complete legal command” version, provided that it sufficiently resembles the other commands.
                    </p>
                    
            </article>
            <footer>
                <ol id="page-numbers">
                    <li>39</li>
                    <li>40</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <h3 style="color: #e0214d;">Analysis</h3>
                    <p>
                      8.30 Describe a modification to the program that would be easier to make to the “get a line, process the eommand word” version than to the
                          “get a complete legal command” version. Explain in general what kinds of changes would be easier to add to each version of the code.
                    </p>
                    <h3 style="color: #e0214d;">Application</h3>
                    <p>
                      8.31 Create a boolean function called LegolDote that returns true if the correct number of legal dates were input and returns false otherwise.
                           The function should call GetDate.
                    </p>
                    <h3 style="color: #e0214d;">Modification</h3>
                    <p>
                      8.32 Modify the GetDate procedure to handle dates entered in the format 1-2-91 as well as in the format 1/2/91.
                    </p>
                    <h3 style="color: #e0214d;">Testing,Reflection</h3>
                    <p>
                      8.33 Provide a set of test data for the “get a complete legal command” version. Which of the two versions is easier to test?
                    </p>
                    <h3 style="color: #e0214d;">Reflection</h3>
                    <p>
                      8.34 Which of the two versions is easier for you to understand? Why?
                    </p>
                         
                     <h2 style="color: #e0214d;background: lavenderblush;">Outline of Design and Development Questions</h2>
                     <p>
                       These questions summarize the main points of the commentary.<br>
                        Planning the Modifications<br>
                        What new features were requested?<br>
                        What changes will produce a file containing the graphs?<br>
                        What changes will implement the new input format?<br>
                        What changes will allow the user to add forgotten data and correct
                        errors?<br>
                        How might the modifications be incorporated?<br>
                        How will the history file editor work?<br>
                        How will the history file format change?<br>
                        How will the date for the current entry be determined?<br>
                        What modifications are needed to go with the new file format?<br>
                        What changes to You Are What You Eat are to be made?
                        What comes first?<br>
                        Implementing Changes to You Are What You Eat 
                        How is PrintGraph changed?<br>
                        How is ReadEntry rewritten?<br>
                     </p>
            
                     <p>
                       In which procedure should the food be looked up?<br>
                      What is the format of the food information file?<br>
                      How is a file of records created?<br>
                      How is the error checking coded?<br>
                      How is the file search coded?<br>
                      How are the fat and calorie amounts coded?<br>
                      How is the code tested?<br>
                      What modifications are necessary to keep track of dates?<br>
                      How will Initialize and Update be modified to handle the new file
                      format?<br>
                      How is the date of the current entry computed?<br>
                      What changes to the top-level decomposition are necessary?<br>
                      How is the code tested?<br>
                      High-Level Design of the History Editor<br>
                      What commands will be provided in the history file editor?<br>
                      How is the history file editor organized?<br>
                      How are the history entries represented?<br>
                      How do we create an abstract view?<br>
                      What operations have we left out?<br>
                      How are the commands and abstract operations related?<br>
                      Is a file or an array best?<br>
                      Implementing the Abstract Operations<br>
                      How is the “find” operation coded?<br>
                      How is a file searched?<br>
                      What happens when an entry is found?<br>
                      How is the “insert” operation coded?<br>
                      How is the “delete” operation coded?<br>
                      How is the “print all entries” operation coded?<br>
                      How is the “print all entries between two given dates” operation coded?<br>
                      How is the “initialize” operation coded?<br>
                      What about the code that manipulates dates?<br>
                      How can the code be tested?<br>
                      What bugs are encountered?<br>
                      Designing and Developing the Remainder of the History Editor<br>
                      What remains to be designed?<br>
                      What should the “get a command” step do?<br>
                      What worked before?<br>
                      How do we select an alternative?<br>
                      What errors will the program check?<br>
                      What are the pros and cons of each decomposition?<br>
                      The “Get the Line, Process the Command Word” Design<br>
                      What will GetCommand and ExecuteCommand do?<br>
                      How will GetCommand and ExecuteCommand communicate?<br>
                     </p>
                     




               


            </article>
            <footer>
                <ol id="page-numbers">
                    <li>41</li>
                    <li>42</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p>
                How will ExecuteCommand work?<br>
                What are the headers for these procedures?<br>
                What is a consistent design for the Get procedures?<br>
                What about illegal commands?<br>
                How should the errors be indicated?<br>
                How is GetCommand coded?<br>
                How does the design of GetCommand affect the main program?<br>
                How is ExecuteCommand designed?<br>
                How is ExecuteList designed?<br>
                How is ExecuteAdd coded?<br>
                How are the remaining Execute routines coded?<br>
                How is the GetDate procedure designed?<br>
                What are possible errors in a date?<br>
                How is GetDate decomposed?<br>
                How is all this code tested and debugged?<br>
                The “Get a Complete Legal Command” Design<br>
                What are the differences between the two designs?<br>
                How will the main program change?<br>
                How will the Execute procedures change?<br>
                How will the new GetCommand be organized?<br>
                How is the command word analyzed?<br>
                How are the arguments analyzed?<br>
                Which version is better?<br>
              </p>
               <h2 style="color: #e0214d;background: lavenderblush;">Programmers' Summary</h2>
               <p>
                 In this case study, we add three features to the You Are What You Eat program. One is to copy the fat and calorie graphs to a file, allowing the user to print them or refer to them later. Another is the use of a food information file to let the user enter food names and serving sizes rather than actual fat and calorie values. The third provides a way for the user to edit the history file.
               </p>
               <p>
                 We could add all the new features to the original program. We choose instead to invent a separate program to do the editing, hoping to provide a
                system of programs that is both easier for the user to understand and easier for us to manage.
               </p>
               <p>
                 Even as separate programs, they each contain several hundred lines of code, larger than any of the programs in earlier case studies. Yet
                  implementing the changes to the You Are What You Eat program is straightforward, as is designing and developing the history file editor. Why? There are two main reasons.
               </p>
               <p>
                 First, each program can be decomposed into sections to handle input, processing, and output, along with another section for accessing and updating
                  the history file. We isolate interaction with the user in the input section,access to the history file in history file section, and so on. As a result, it is clear where to make each modification to the original You Are What You Eat program. Each of the sections in both programs can be tested separately, reducing the probability of undetected bugs.
               </p>
               <p>
                 Second, almost all the code results from applying templates from previous case studies. Array searching and processing templates are adapted to
                search and process the history and food files. (These templates suggest good test data as well.) The '‘select from alternatives” template forms the
                backbone of the code to execute commands in the history file editor. Routines to read food names, servings, editor commands, and arguments are
                patterned on code from Is It Legal?, Space Text, and You Are What You Eat.Code to check dates for legality is copied from The Calendar Shop. This reliance on previously developed code makes the program both easier to design, since we are designing very little code from scratch, and easier to test and debug, since we have already tested the code or something very similar before.
               </p>
               <p>
                 We use multiple debugging switches in the new version of You Are What You Eat so that we can focus on the actions in a particular program section
                rather than wade through debugging output for all the sections. In the history file editor, we do not have any debugging switch, relying instead on
                the list commands already being built into the editor. (For this reason, the list command is the first command we test and debug.)
               </p>
               <p>
                 The decision made in You Are What You Eat to store file entries most recent first may have been unwise. It complicates the design of code to
                 search the file and leads to at least one bug.
               </p>
               <p>
                 The main program for the history file editor is an application of the “input one, process one” template, commonly known as a command interpret¬
                  er. It consists of a loop that first reads, then executes a command. In any command interpreter, there is the question of how much to do in each
                  step. “Reading” a command might be as little as reading its characters into a string or as much as analyzing all the command’s components for legality and translating them into an internal form. We design two versions of the code. In one, the “get a line, process the command word” version, the “read a command” step reads a line of input, then classifies the first word as a command; command execution routines isolate the command arguments from the line. In the other, the “get a complete legal command”version, the “read a command” step reads and analyzes the entire command. The choice between the two approaches depends on how similar commands are to one another—the more similar, the better the “get a complete legal command” version—and on what modifications are anticipated for the program.
               </p>


             
            </article>
            <footer>
                <ol id="page-numbers">
                    <li>43</li>
                    <li>44</li>
                </ol>
            </footer>
        </section>
        <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
             <p>
               Several decomposition questions are encountered. At what point should the food name be looked up in the food information file? At what point
               should the current date be determined.^ Where should errors be handled?These all are answered to maintain consistency with other parts of the
                program and to isolate references to program data structures in a small number of routines.
             </p>
             <p>
               Pascal constructs introduced in this case study include enumerated types (for commands and error status indicators) and files of records. Members
                of an enumerated type are used in the same way as integer constants were in The CalendarShop and h ItLegal? The advantage of an enumerated type
                is that it can be concisely defined; its disadvantage is that values of the type cannot be printed and can be manipulated only with the ord, pred,
                and succ functions. A file of records allows information to be input without being analyzed. This saves code and execution time. The disadvantages
                of a file of records are that it can be created only by a program, not by a text editor; its contents can be printed only by a program; and one must
                ensure that the file-creating program and the file-reading program are using identical definitions for the components of the file.
             </p>
             <h2 style="color: #e0214d;background: lavenderblush;">Making Sense of You Forgot What You Ate</h2>
              <h3 style="color: #e0214d;">Analysis</h3>
              <p>
                8.35 Describe the advantages of using an array rather than a file for the history entries. What routines would have been designed differently
                     if an array had been used?
              </p>
              <h3 style="color: #e0214d;">Reflection</h3>
              <p>
                8.36 Would a replace command have been more confusing than the odd and delete commands? Why or why not?
              </p>              
              <h3 style="color: #e0214d;">Reflection</h3>
              <p>
                8.37 Would the design process have been just as easy if we had started with the “get a complete legal command” version of the program
                 instead of the “get a line, process the command word” version? Why or why not?
              </p>
              <h3 style="color: #e0214d;">Reflection</h3>
              <p>
                8.38 Suppose one of your friends volunteered to make the revisions to You Are What You Eat. What would you need to tell your friend about
                     the program in order to orient him or her to the code and design most effectively?
              </p>
              <h3 style="color: #e0214d;">Reflection</h3>
              <p>
                Suppose you were working with a programming partner on the revisions. How would you split the task most equitably.? What
                 coordination problems would you expect?
              </p>
              <h3 style="color: #e0214d;">Debugging</h3>
              <p>
                8.40 Add mutations to the code, and get another programmer to find them. Where in the code are bugs most difficult to detect?
              </p>
               <h3 style="color: #e0214d;">Debugging</h3>
               <p>
                 8.41 It is possible for the history file editor in the Pascal Code section to leave fewer than thirty entries in the history file, and the revised You Are What You Eat program will crash as a result. Describe circumstances under which this will happen.
               </p>
               <h3 style="color: #e0214d;">Reflection</h3>
               <p>
                 The bug described in question 8.41 involved the interaction between two programs. How does testing and debugging the 
                 interaction between two programs differ from testing and debugging the interaction between two subprograms?
               </p>
               <h3 style="color: #e0214d;">Modification</h3>
               <p>
                 8.43 Fix the bug described in question 8.41. In which program should the fix be incorporated?
               </p>
               <h3 style="color: #e0214d;">Modification</h3>
               <p>
                 8.44 Modify the programs designed in You Forgot What You Ate so that all the user input of fat and calorie information is read in one program,
                      and all the graphing is done in another. Compare this organization to the one we produced.
               </p>
               <h3 style="color: #e0214d;">Application</h3>
               <p>
                 8.45 Write a program to manipulate a library data base. Each entry in the data base contains information about a book: its title, its lending 
                 status, and the date it is to be returned. The program should accept commands that add a book to the data base, delete a book from the
                  data base, signal that the book has been borrowed, signal that the book has been returned, and list all the books currently loaned out.
               </p>
                <h2 style="color: #e0214d;background: lavenderblush;">Linking to Previous Case Studies</h2>
                <h3 style="color: #e0214d;">Reflection</h3>
                <p>
                  8.46 In both You Are What You Eat and in You Forgot What You Ate, we encountered a choice between using an array and using a file. Compare
                      the circumstances in the two case studies. Which circumstances were similar and which were different? 
                </p>

                <h3 style="color: #e0214d;">Reflection</h3>

                <p>
                  8.47 How does separating the design of abstract operations for a data type from the design of the code for those operations help isolate code
                        that may later need to be modified?
                </p>
                <h3 style="color: #e0214d;">Reflection</h3>
                <p>
                  8.48 In what ways are the design of abstract operations for a data type similar to those of postponing details in The Calendar Shop?
                </p>
                <h3 style="color: #e0214d;">Applicatin
                  <p>
                    8.49 The programs in this case study use code from The Calendar Shop to manipulate dates. Describe some other applications in which code
                          that manipulates dates would be useful, and indicate what other operations on dates would have to be implemented in the applications
                          you describe.
                  </p>

                <h3 style="color: #e0214d;">Reflection</h3>










            </article>
            <footer>
                <ol id="page-numbers">
                    <li>45</li>
                    <li>46</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <h2 style="color: #e0214d;background: lavenderblush;">Revisions to You Are What You Eat</h2>
               <p style="font:16px Courier New">
                type
                  MonthTVpe = (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE,
                  JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER);
                  DayType = 1..31;
                  YearType = 1990..2100;
                  DateType = record
                  month: MonthType;
                  day: DayType;
                  year: YearType;
                  end;
                  EntryType = record
                  date: DateType;
                  fat, calories: integer;
                  end;
                  HistoryType = array[0..HISTORYSIZE] of EntryType;
                  HistoryFileType = file of EntryType;
                  StringType = packed array[1..MAXSTRLEN] of char;
                  FoodEntryType = record
                  foodName: StringType;
                  servingDescr: StringType;
                  fat, calories: integer;
                  end;
                  FoodInfoType = file of FoodEntryType;
                  var
                  historyFile: HistoryFileType;
                  foodinfo: FoodInfoType;
                  testFile: text;
                  entry: EntryType;
                  recentHistory: HistoryType;
                  Print the date, followed by a carriage return.
                  }
                  procedure WritelnDate (date: DateType);
                  begin {Writeln Date}
                  case date.month of
                  JANUARY: write(''January ');
                  FEBRUARY: write( 'February ');
                  MARCH: write( 'March ’);
                  APRIL: write( 'April ');
                  MAY: write( 'May ');
                  JUNE: write( 'June ');
                  JULY: write('July ');
                  AUGUST: write( 'August ');
                  SEPTEMBER : write('September ');
                  OCTOBER: write( 'October ');
                  NOVEMBER: write( 'November ');
                  DECEMBER: write( 'December ');
                  end;
                  writeln(date. day : 1, ', ', date.year
                  end; (Writeln Date}
                  {
                  Return true exactly when year is a leap year.
                  }
                  function LeapYear (year: YearType): boolean;
                  begin {Leap Year?}
                  LeapYear := (year div 400 = 0)
                  or ((year div 4=0) and (year div 100 <> 0));
                  end; (Leap Year?}
                  {
                  Return 1 when year is a leap year, 0 otherwise.
                  }
                  function LeapDay (year: YearType): integer;
                  begin (Leap Day}
                  if LeapYear(year) then begin
                  LeapDay := 1;
                  end else begin
                  LeapDay := 0;
                  end;
                  end; {Leap Day}
                  {
                  Return the nuinber of days in the given month.
                  }
                  function NumberOfDaysIn (month: MonthType; year: YearType): DayType;
                  begin (Number Of Days In}
                  case month of
                  JANUARY, MARCH, MAY, JULY, AUGUST, OCTOBER, DECEMBER:
                  NumberOfDaysIn := 31;
                  FEBRUARY:
                  NumberOfDaysIn := 28 + LeapDay(year);
                  APRIL, JUNE, SEPTEMBER, NOVEMBER:
                  NumberOfDaysIn := 30;
                  end;
                  end; (Number Of Days In}
                  {
                  Return in next the date after the date in current.
                  }
                  procedure FindSuccessor (current: DateType; var next: DateType);
                  begin (Find Successor}
                  if current.day < NumberOfDaysIn(current.month, current.year)
                  then begin
                  next.month := current.month;
                  next.day := current.day + 1;
                  next.year := current.year;
                  end else if current.month < DECEMBER then begin
                  next.month := succ(current.month);
                  next.day := 1;
                  next.year := current.year;
                  end else begin
                  next.month := JANUARY;
                  next.day := 1;
                  next.year := current.year + 1;
                  end;
                  </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>47</li>
                    <li>48</li>
                </ol>
            </footer>
        </section>
  
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p style="font:16px Courier New">
                  if DEBUGDATES then begin
                  write (’*** the day after ');
                  WritelnDate (current);
                  write (' is ');
                  WritelnDate (next);
                  end;
                  end; {Find Successor}
                  {
                  Return true exactly when numServings constitutes a reasonable serving
                  size.
                  }
                  function IsInSein/ingRange (numServings: integer): boolean;
                  begin (Is In Serving Range?}
                  IsInServingRange (numServings >= 0)
                  and (numServings <= MAXSERVINGS);
                  end; (Is In Serving Range?}
                  {
                  line contains a food name. Search for it in foodinfo. If it's there,
                  return true in found and return the corresponding food entry in
                  foodEntry; otherwise return false in found.
                  }
                  procedure Search (line: LineType; var foodEntry: FoodEntryType;
                  var found: boolean);
                  begin {Search}
                  reset(foodinfo);
                  found := false;
                  while not eof(foodinfo) and not found do begin
                  read(foodinfo, foodEntry);
                  found := Equal(line, foodEntry.foodName);
                  if DEBUGFOOD then begin
                  writeln ('*** checking ', foodEntry.foodName);
                  end;
                  end;
                  end; {Search}
                  {
                  Ask the user for a food name, and keep prompting until a legal food
                  name is provided. The user may either supply a food name, in which case
                  the corresponding entry from foodinfo is returned in foodEntry and
                  false is returned in done, or the word "done", in which case true is
                  returned in done.
                  }
                  procedure ReadFood (var inFile: text; var foodEntry: FoodEntryType;
                  var done: boolean);
                  var
                  error, found: boolean; line: LineType;
                  begin {Read Food}
                  done := false;
                  repeat
                  error :- false;
                  writeln('Please type either a food name');
                  writeln('or type the word "done"--without the quotes—’,
                  'if you''re finished.');
                  ReadTrimmedLine(inFile, line);
                  if Empty(line) then begin
                  error := true;
                  end else if Equal(line, DONESTR) then begin
                  done := true;
                  end else begin
                  Search(line, foodEntry, found);
                  if not found then begin
                  error := true;
                  end;
                  end;
                  if error then begin
                  writeln('That food is not in the dictionary of foods.');
                  end;
                  until done or not error;
                  end; {Read Food}
                  {
                  Ask the user for a number of servings, and keep prompting until a legal
                  number is provided. foodEntry contains information about the serving
                  units that is printed in the prompt. Return the number in numServings.
                  }
                  procedure ReadServings (var inFile: text; foodEntry: FoodEntryType;
                  var numServings: integer);
                  var
                  error: boolean; line: LineType;
                  begin (Read Servings}
                  repeat
                  error := false;
                  writeln('How many servings? One serving = ',
                  foodEntry.servingDescr);
                  ReadTrimmedLine(inFile, line);
                  if Empty(line) then begin
                  error := true;
                  end else if not IsAllDigits(line) then begin
                  error := true;
                  end else begin
                  numServings := IntegerValue(line);
                  if not IsInServingRange(numServings) then begin
                  error := true;
                  end;
                  end;
                  if error then begin
                  writeln('You must provide an integer number of servings, ',
                  'no more than', MAXSERVINGS);
                  end;
                  until not error;
                  end; (Read Servings}
                  {
                  Read today's food entry from the user, returning it in entry.
                  }
                  procedure ReadEntry (var inFile: text; today: DateType;
                  var entry: EntryType);
                  var
                  numServings: integer; done: boolean; foodEntiry: FoodEntryType;
                  begin (Read Entry}
                  </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>49</li>
                    <li>50</li>
                </ol>
            </footer>
        </section>
  
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p style="font:16px Courier New">
                entry.date := today;
                entry.fat := 0;
                entry.calories := 0;
                repeat
                ReadFood(inFile, foodEntry, done);
                if not done then begin
                ReadServings(inFile, foodEntry, numServings);
                entry.fat := entry.fat + numServings * foodEntry.fat;
                entry.calories := entry.calories
                + numServings * foodEntry.calories;
                if DEBUGFOOD then begin
                writeln ('*** accumulated fat = entry.fat:1,
                ' accumulated calories = entry.calories:1);
                end;
                end;
                until done;
                end; {Read Entry}
                {
                Initialize recentHistory from this history file.
                }
                procedure Initialize (var historyFile: HistoryFileType;
                var recentHistory: HistoryType);
                var
                testFile: text; numEntries, dayNum: integer;
                entry: EntrylVpe; today: DatelVpe;
                begin (Initialize)
                numEntries := 0;
                reset(historyFile);
                for dayNum := 1 to HISTORYSIZE do begin
                read(historyEile, recentHistory [dayNum]);
                if DEBUGHISTORY then begin
                write ('*** from history: ');
                WritelnDate (recentHistory[dayNum].date);
                ^jriteln ( ' fat = ' , recentHistory [dayNum] .fat:l,
                ’ calories = recentHistory[dayNum].calories:!);
                end;
                end;
                FindSuccessor(recentHistory[1] .date, today);
                write('The food data you are about to enter is assumed to be for )
                WritelnDate(today);
                writeln('Quit this program and run the history file editor ',
                'if this is incorrect.');
                if FILEINPUT then begin
                ReadEntry (testEile, today, recentHistory[0]);
                end else begin
                ReadEntry(input, today, recentHistory[0]);
                end;
                end; (Initialize)
                (
                Write the new recentHistory values to the history file.
                )
                procedure Update (var historyEile: HistoryFileType;
                recentHistory: HistoryType);
                var
                dayNum: integer; entry; EntryType; tempFile: HistoryFileType;
                begin {Update}
                rewrite(tempFile);
                for dayNum := 0 to HISTORYSIZE do begin
                write(tempFile, recentHistory[dayNum]);
                end;
                while not eof(historyFile) do begin
                read(historyFile, entry);
                write(tempFile, entry);
                if DEBUGHISTORY then begin
                writeln('*** to temp file: ', entry.fat, entry.calories);
                end;
                end;
                reset(tempFile);
                rewrite(historyFile);
                while not eof(tempFile) do begin
                read(tempFile, entry);
                write(historyFile, entry);
                if DEBUGHISTORY then begin
                writeln('*** to history file: ', entry.fat, entry.calories);
                end;
                end;
                end; (Update)
                begin
                reset(foodinfo);
                Initialize(historyFile, recentHistory);
                PrintAverages(recentHistory);
                PrintGraphs(recentHistory);
                Update(historyFile, recentHistory);
                end.
                </p>
                <h2 style="color: #e0214d;background: lavenderblush;">Implementation of the Abstract History File Operations</h2>
                 <p style="font:16px Courier New">
                  {
                  Print the information in the given entry.
                  }
                  procedure PrintEntry (entry; EntryType);
                  begin (Print Entry)
                  write('Date = ');
                  WritelnDate(entry.date);
                  writeln('Fat = ', entry.fat : 1, ', calories = ', entry.calories : 1);
                  end; (Print Entry)
                  {
                  Read the information for a food entry.
                  )
                  procedure ReadEntry (var entry: EntryType);
                  (The code for ReadEntry appears in the previous section.)
                  {
                  Copy remaining elements from original to temp, then copy all elements
                </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>51</li>
                    <li>52</li>
                </ol>
            </footer>
        </section>
  
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p style="font:16px Courier New">
                in temp back to original.
                }
                procedure CopyThenCopyBack (var original: SequenceType;
                var temp: PositionType);
                var
                entry: EntryType;
                begin {Copy Then Copy Back}
                while not eof(original) do begin
                read(original, entry);
                write(temp, entry);
                end;
                reset(temp);
                rewrite(original);
                while not eof(temp) do begin
                read(temp, entry);
                write(original, entry);
                end;
                end; (Copy Then Copy Back)
                {
                Search for an entry with the given date in history, while copying
                entries from history to temp. Read only as far as necessary in history.
                If an entry with the given date is found, return it in entry and return
                true in found; otherwise return false in found, temp will represent
                the position either of the entry found or the entry with the next
                earlier date if the search is unsuccessful.
                }
                procedure Find (var history: SequenceType; date: DateType;
                var found: boolean; var entry: EntryType; var temp: PositionType);
                var
                foundAtOrBefore: boolean;
                begin (Find)
                reset(history);
                rewrite(temp);
                foundAtOrBefore := false;
                while not foundAtOrBefore and not eof(history) do begin
                read(history, entry);
                if AtOrBefore(entry.date, date) then begin
                foundAtOrBefore := true;
                end else begin
                write(temp, entry);
                end;
                end;
                if foundAtOrBefore then begin
                found := Same(date, entry.date);
                end else begin
                found := false;
                end;
                end; (Find)
                {
                Insert the given entry at the given position {temp) in history.
                }
                procedure Insert (var history: SequenceType; entry: EntryType;
                var temp: PositionType);
                begin (Insert)
                write(temp, entry);
                CopyThenCopyBack(history, temp);
                end; {Insert}
                {
                Delete the entry at the given position (temp) in history.
                }
                procedure Delete (var history: SequenceType; var temp: PositionType);
                begin {Delete}
                CopyThenCopyBack(history, temp);
                end; {Delete}
                {
                Print all entries in history.
                }
                procedure PrintAll (var history: SequenceType);
                var
                entry: EntryType ;
                begin {Print All}
                reset(history);
                while not eof(history) do begin
                read(history, entry);
                PrintEntry(entry);
                end;
                end; {Print All}
                {
                Print all entries in history up to and including the given date.
                }
                procedure PrintUpTo (var history: SequenceType; date: DateType;
                var temp: PositionType);
                var
                done: boolean; entry: EntryType;
                begin {Print Up To}
                done := false;
                while not done and not eof(history) do begin
                read (histoiry, entiy) ;
                if AtOrBefore(date, entry.date) then begin
                PrintEntry (entry);
                end else begin
                done := true;
                end;
                end;
                end; {Print Up To}
                {
                Initialize history.
                }
                procedure Initialize (var history: SequenceType);
                begin {Initialize}
                reset(history);
                end; {Initialize}
                </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>53</li>
                    <li>54</li>
                </ol>
            </footer>
        </section>
  
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <h2 style="color: #e0214d;background: lavenderblush;">The Rest of the History Editor</h2>
                 <p style="font:16px Courier New">
                  program HistoryEditor (input, output, history);
                  const
                  BLANK = ' ';
                  DATESEPARATOR = ’/';
                  MAXLINELEN = 80;
                  MAXWORDLEN = 20;
                  LISTWORD = 'list
                  ADDWORD = 'add
                  DELETEWORD = 'delete
                  HELPWORD = 'help
                  QUITWORD = 'quit
                  BLANKWORD = '
                  type
                  LineType = record
                  chars: array[1..MAXLINELEN] of char;
                  length: integer;
                  position: integer;
                  end;
                  WordType = packed array[1..MAXWORDLEN] of char;
                  ConmandlVpe = (LISTCMD, ADDCMD, DELETECMD, HELPCMD, QUITCMD, UNKNOWN);
                  StatusType = (SUCCESS, NOINPUT, LINETOOLONG, NOWORD, WORDTOOLONG,
                  NOCOMMAND, BADCOMMAND, NODATE, TOOMANYDATES, BADNUM, BADSEP,
                  EXTRAJUNK, BADDATE, ALREADYTHERE, NOTTHERE, EMPTYRANGE);
                  MonthType = (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE,
                  JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER);
                  DayType = 1. .31;
                  YearType = 1990..2100;
                  DateType = record
                  month: MonthType;
                  day: DayType;
                  year: YearType;
                  end;
                  EntryType = record
                  date: DateType;
                  fat, calories: integer;
                  end;
                  SequenceType = file of EntryType;
                  PositionType = file of EntryType;
                  var
                  history: SequenceType;
                  done: boolean;
                  line: LineType;
                  command: CommandType;
                  status: StatusType;
                  {*** error message printer ***}
                  procedure PrintErrorMsg (status: StatusType);
                  begin {Print Error Message}
                  case status of
                  SUCCESS: writeln('*** INTERNAL ERROR IN PROGRAM ***');
                  NOINPUT: writeln('*** Input ran out unexpectedly. ***');
                  LINETOOLONG: writeln('*** There is too much text
                  'on the command line. ***');
                  NOWORD: writeln('*** INTERNAL ERROR IN PROGRAM ***');
                  WORDTOOLONG: writeln('*** A word on the command line
                  'is too long. ***');
                  NOCOMMAND: writeln('*** There is nothing. ',
                  'on the command line. ***');
                  BADCOMMAND: writeln('*** The first word on the line ',
                  'is not a legal command. ***');
                  NODATE: writeln('*** INTERNAL ERROR IN PROGRAM ***');
                  TOOMANYDATES: writeln('*** Too many dates were specified ',
                  'for this command. ***');
                  BADNUM: writeln('*** The month, day, or year ',
                  'is illegal. ***');
                  BADSEP: writeln('*** The month and day must ',
                  be separated by a slash, as must the day and year. ***');
                  EXTRAJUNK: writeln('*** Extra text appears ',
                  'after the year. ***');
                  BADDATE: writeln('*** The number of days in the month ',
                  'is incorrect. ***');
                  ALREADYTHERE: writeln('*** There is already an entry ',
                  'for that date. ***');
                  NOTTHERE: writeln('*** There is no entry for that date. ***
                  EMPTYRANGE: writeln('*** There are no entries between ',
                  'the two given dates. ***');
                  end;
                  end; {Print Error Message}
                  {*** utility routines ***}
                  Return true exactly when ch is a digit.
                  }
                  function IsDigit (ch: char): boolean;
                  begin (Is Digit?)
                  IsDigit := ch in ['0'..'9'];
                  end; (Is Digit?)
                  (
                  Return the numeric value of the given digit.
                  }
                  function DigitValue (ch: char): integer;
                  begin (Digit Value)
                  DigitValue := ord(ch) - ord('O');
                  end; (Digit Value)
                  {
                  Get the next word from line and return it in word. Update the line
                  position. Return the result of the word scanning in status: success
                  no words left in line, or too long a word.
                  }
                  procedure GetWord (var line: LineType; var word: WordType;
                  var status: StatusType);
                  </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>55</li>
                    <li>56</li>
                </ol>
            </footer>
        </section>
     <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p style="font:16px Courier New">

                  var
                  done: boolean; length: integer;
                  begin {Get Word)
                  status := SUCCESS;
                  done := false;
                  while not done do begin
                  if line.position > line.length then begin
                  status := NOWORD;
                  done := true;
                  end else if line.chars[line.position] <> BLANK then begin
                  done := true;
                  end else begin
                  line.position := line.position + 1;
                  end;
                  end;
                  if status = SUCCESS then begin
                  done := false;
                  word := BLANKWORD;
                  length := 1;
                  word[l] line, chars [line, posit ion] ;
                  line.position := line.position + 1;
                  while not done do begin
                  if line.position > line.length then begin
                  done := true;
                  end else if line.chars[line.position] = BLANK then begin
                  done := true;
                  end else if length = MAXWORDLEN then begin
                  status := WORDTOOLONG;
                  done := true;
                  end else begin
                  length := length + 1;
                  word[length] := line.chars[line.position];
                  line.position := line.position + 1;
                  end;
                  end;
                  end;
                  end; (Get Word}
                  {
                  Read a line from the user. Possible values to return in status are
                  success, no lines to read (user indicated end-of-file), or line too
                  long to store.
                  }
                  procedure GetLine (var line: LineType; var status: StatusType);
                  var
                  ch: char;
                  begin (Get Line)
                  status := SUCCESS;
                  if eof then begin
                  status := NOINPUT;
                  end else begin
                  line.length := 0;
                  line.position := 1;
                  while not eoln do begin
                  read(ch);
                  if line.length = MAXLINELEN then begin
                  status := LINETOOLONG;
                  end else begin
                  line.length := line.length + 1;
                  line.chars[line.length] := ch;
                  end;
                  end;
                  readln;
                  end;
                  end; {Get Line}
                  {*** date operations ***}
                  {
                  Return true exactly when datel precedes date2.
                  }
                  function Precedes (datel, date2: DateType): boolean;
                  begin (Precedes?)
                  if datel.year < date2.year then begin
                  Precedes ;= true;
                  end else if datel.year > date2.year then begin
                  Precedes := false;
                  end else if datel.month < date2.month then begin
                  Precedes := true;
                  end else if datel.month > date2.month then begin
                  Precedes := false;
                  end else begin
                  Precedes := datel.day < date2.day;
                  end;
                  end; (Precedes?)
                  {
                  Return true exactly when datel and date2 are identical.
                  }
                  function Same (datel, date2: DateType): boolean;
                  begin (Same?)
                  Same := (datel.month = date2.month) and (datel.day = date2.day)
                  and (datel.year = date2.year);
                  end; (Same?)
                  {
                  Return true when datel comes at or before date2.
                  }
                  function AtOrBefore (datel, date2: DateType): boolean;
                  begin (At or Before?)
                  AtOrBefore := Same(datel, date2) or Precedes(datel, date2);
                  end; (At or Before?)
                  {
                  Return true exactly when year is a leap year.
                  }
                  function LeapYear (year: YearType): boolean;
                  begin (Leap Year?)
                  LeapYear := (year mod 400 = 0)
                  or ((year mod 4=0) and (year mod 100 <> 0));
                  end; (Leap Year?)
                  </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>57</li>
                    <li>58</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p style="font:16px Courier New">
              Return 1 if year is a leap year, 0 otherwise.
                }
                function LeapDay (year: YearType): integer;
                begin {Leap Day}
                if LeapYear(year) then begin
                LeapDay := 1;
                end else begin
                LeapDay := 0;
                end;
                end; {Leap Day)
                {
                Return the number of days in the given month in the given year.
                }
                function NumberOfDaysIn (month: integer; year: YearType): DayType;
                begin {Number Of Days In}
                case month of
                1, 3, 5, 7, 8, 10, 12:
                NumberOfDaysIn := 31;
                2:
                NumberOfDaysIn := 28 + LeapDay(year);
                4, 6, 9, 11:
                NumberOfDaysIn := 30;
                end;
                end; {Number Of Days In}
                {
                Return the nth element of the MonthType enumerated type.
                }
                function MonthEquiv (n: integer): MonthType;
                var
                k: integer; m: MonthType;
                begin {Month Equivalent}
                m := JANUARY;
                for k := 1 to n - 1 do begin
                m := succ(m) ;
                end;
                MonthEquiv := m;
                end; {Month Equivalent}
                {
                Print a date followed by a carriage return.
                }
                procedure WritelnDate (date: DateType);
                begin {Writeln Date}
                case date.month of
                JANUARY: write( 'January '
                FEBRUARY: write('February
                MARCH: write( ’March ');
                APRIL: write( 'April ');
                MAY: write( 'May ');
                JUNE: write( 'June ');
                JULY: write( 'July ');
                AUGUST: write( 'August ')
                SEPTEMBER: write( 'SeptemberOCTOBER; write('October ');
                NOVEMBER: write('November ');
                DECEMBER: write('December ');
                end;
                writeln(date.day : 1, date.year : 4);
                end; {Writeln Date}
                {
                Translate word to a one- or two-digit numeric value and return the
                result in n. Also increment the index position in word.
                If word doesn't contain one or two digits, indicate an error in status
                }
                procedure GetOneOrTwoDigits (word: WordType; var index: integer;
                var n: integer; var status: StatusType);
                begin (Get One or Two Digits}
                if IsDigit(word[index]) and not IsDigit(word[index + 1]) then begin
                n := DigitValue(word[index]);
                index ;= index + 1;
                end else if IsDigit(word[index])
                and IsDigit(word[index + 1]) then begin
                n := 10 * DigitValue(word[index]) + DigitValue(word[index +1]);
                index := index + 2;
                end else begin
                status := BADNUM;
                end;
                end; (Get One or Two Digits}
                {
                If the character in the given position in word {index) is a date
                separator, increment the position; otherwise indicate error in status
                }
                procedure GetSeparator (word: WordType; var index: integer;
                var status: StatusType);
                begin (Get Separator}
                if word[index] = DATESEPARATOR then begin
                index := index + 1;
                end else begin
                status := BADSEP;
                end;
                end; (Get Separator}
                {
                Translate word to a four-digit numeric value and return the result in
                n. Also increment the index position in word.
                If word doesn't contain four digits, indicate an error in status.
                }
                procedure GetFourDigits (word: WordType; var index: integer;
                var n: integer; var status: StatusType);
                begin (Get Four Digits}
                if IsDigit(word[index]) and IsDigit(word[index+1])
                and IsDigit(word[index+2]) and IsDigit(word[index+3]) then begin
                n := 1000 * DigitValue(word[index])
                + 100 * DigitValue(word[index + 1])
                + 10 * DigitValue(word[index +2])
                + DigitValue(word[index + 3]);
                index := index + 4;
                </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>59</li>
                    <li>60</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p style="font:16px Courier New">
                  end else begin
                status := BADNUM;
                end;
                end; {Get Four Digits}
                {
                If there are unprocessed characters in word, indicate that in status.
                }
                procedure CheckNoMore (word: WordType; index: integer;
                var status: StatusType);
                begin (Check No More}
                if word[index] <> BLANK then begin
                status := EXTRAJUNK;
                end;
                end; (Check No More}
                {
                Return true exactly when month, day, and year collectively represent
                a legal date.
                }
                function LegalDate (month, day, year: integer): boolean;
                begin (Legal Date?}
                if not (month in [1..12]) then begin
                LegalDate := false;
                end else begin
                LegalDate := day in [1..NumberOfDaysIn(month, year)];
                end;
                end; (Legal Date?}
                {
                Get a legal date from line, and return it in date. If the next word in
                line does not represent a legal date, indicate the fact in status.
                }
                procedure GetDate (var line: LineType;
                var date: DateType; var status: StatusType);
                var
                word: WordType; index: integer; month, day, year: integer;
                begin (Get Date}
                GetWord(line, word, status);
                if status = NOWORD then begin
                status := NODATE;
                end;
                if status = SUCCESS then begin
                index := 1;
                GetOneOrTwoDigits(word, index, month, status);
                end;
                if status = SUCCESS then begin
                GetSeparator(word, index, status);
                end;
                if status = SUCCESS then begin
                GetOneOrTwoDigits(word, index, day, status);
                end;
                if status = SUCCESS then begin
                GetSeparator(word, index, status);
                end;
                if status = SUCCESS then begin
                GetFourDigits(word, index, year, status);
                end;
                if status = SUCCESS then begin
                CheckNoMore(word, index, status);
                end;
                if status = SUCCESS then begin
                if not LegalDate(month, day, year) then begin
                status := BADDATE;
                end else begin
                date.month := MonthEquiv(month);
                date.day := day;
                date.year year;
                end;
                end;
                end; {Get Date}
                {*** operations on the history file are in the previous section ***}
                {*** Command-scanning procedures ***}
                (
                Get a command word from the line, and return it (translated to the
                corresponding CommandType member} in command. If the next word in line
                does not represent a legal command, indicate the fact in status.
                }
                procedure GetCmdWord (var line: LineType;
                var command: CommandType; var status: StatusType);
                var
                word: WordType;
                begin (Get Command Word}
                status := SUCCESS;
                command := UNKNOWN;
                GetWord(line, word, status);
                if status = NOWORD then begin
                status := NOCOMMAND;
                end else if word = LISTWORD then begin
                command := LISTCMD;
                end else if word = ADDWORD then begin
                command := ADDCMD;
                end else if word = DELETEWORD then begin
                command := DELETECMD;
                end else if word = HELPWORD then begin
                command := HELPCMD;
                end else if word = QUITWORD then begin
                command := QUITCMD;
                end else begin
                status := BADCOMMAND;
                end;
                end; (Get Command Word}
                {
                Prompt the user for a command, and return what is typed in command and
                the result of analyzing its first word in status.
                }
                procedure GetCommand (var line: LineType;
                var command: CommandType; var status: StatusType);
                </p>
              </article>
            <footer>
                <ol id="page-numbers">
                    <li>61</li>
                    <li>62</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p style="font:16px Courier New">
                  begin {Get a Command}
                write('COMMAND? ');
                GetLine(line, status);
                if status = NOINPUT then begin
                command := QUITCMD;
                status := SUCCESS;
                end else if status = SUCCESS then begin
                GetCmdWord(1ine, command, status);
                end;
                end; (Get a Command}
                {*** command interpreting procedures ***}
                {
                A list command has been given; analyze its arguments and, if it's
                legal, execute it. A legal list command has one of the following forms:
                To print the entire history:
                list
                To print the entry for a given date:
                list date
                To print all entries between two dates:
                list datel date2
                }
                procedure ExecuteList (var line: LineType;
                var history: SequenceType; var status: StatusType);
                var
                dates: array[1..2] of DateType;
                tempDate: DateType; numDates: integer;
                done, found: boolean; position: PositionType; entry: EntryType;
                begin (Execute List}
                done := false;
                numDates := 0;
                while not done do begin
                GetDate(line, tempDate, status);
                if status <> SUCCESS then begin
                done := true;
                end else if numDates = 2 then begin
                status := TOOMANYDATES;
                done := true;
                end else begin
                numDates := numDates + 1;
                dates[numDates] := tempDate;
                end;
                end;
                if status = NODATE then begin
                status := SUCCESS;
                case numDates of
                0: PrintAll(history) ;
                1: begin
                Find(history, dates[l], found, entry, position);
                if found then begin
                PrintEntry(entry);
                end else begin
                status := NOTTHERE;
                end;
                end;
                2: begin
                Find(history, dates[l], found, entry, position);
                if not (AtOrBefore(entry.date, dates[2])
                and AtOrBefore(dates[1], entry.date)) then begin
                status := EMPTYRANGE;
                end else begin
                PrintEntry(entry);
                PrintUpTo(history, dates[l], position);
                end;
                end;
                end;
                end;
                end; {Execute List}
                (
                An add coinmand has been given; analyze its arguments and, if it's
                legal, execute it. The add command has the following format:
                add date
                The history must not contain an entry with the given date.
                }
                procedure ExecuteAdd (var line: LineType;
                var history: SequenceType; var status: StatusType);
                var
                date, tempDate: DateType;
                entry: EntryType; found: boolean; position: PositionType;
                begin (Execute Add}
                GetDate(line, date, status);
                if status = SUCCESS then begin
                GetDate(line, tempDate, status);
                if status = SUCCESS then begin
                status := TOOMANYDATES;
                end else if status = NODATE then begin
                status := SUCCESS;
                end;
                end;
                if status = SUCCESS then begin
                Find(history, date, found, entry, position);
                if found then begin
                status := ALREADYTHERE;
                end else begin
                entry.date := date;
                ReadEntry (entry);
                Insert(history, entry, position);
                end;
                end;
                end; {Execute Add}
                (
                A delete command has been given; analyze its arguments and, if it's
                legal, execute it. The delete command has the following format:
                delete date
                The history must contain an entry with the given date.
                }
                procedure ExecuteDelete (var line: LineType;
                var history: SequenceType; var status: StatusType);
                var
                </p>
                </article>
            <footer>
                <ol id="page-numbers">
                    <li>63</li>
                    <li>64</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
                <p style="font:16px Courier New">
                  date, tempDate: DateType;
                entry: EntryType; found: boolean; position: PositionType;
                begin {Execute Delete}
                GetDate(line, date, status);
                if status = SUCCESS then begin
                GetDate(line, tempDate, status);
                if status = SUCCESS then begin
                status := TOOMANYDATES;
                end else if status = NODATE then begin
                status := SUCCESS;
                end;
                end;
                if status = SUCCESS then begin
                Find(history, date, found, entry, position);
                if not found then begin
                status := NOTTHERE;
                end else begin
                entry.date := date;
                Delete(history, position);
                end;
                end;
                end; (Execute Delete}
                {
                Print helpful information.
                }
                procedure ExecuteHelp (var line: LineType;
                var history: SequenceType; var status: StatusType);
                begin (Execute Help}
                writeln('Command formats appear below. Where the notation ');
                writeln('appears, you''re supposed to supply a legal date, ');
                writeln('for instance, 9/24/1992.');
                writeln('To get this message:');
                writeln(' help');
                writeln('To leave the history editor:');
                writeln(' quit');
                writeln('To list the information for all history entries:');
                writeln(' list');
                writeln('To list the information for the entry for a given date:');
                writeln(' list ');
                writeln('To list the information for all entries between two dates:');
                writeln(' list ');
                writeln('To add an entry for a given date:');
                writeln(' add ');
                writeln('To delete the entry for a given date:');
                writeln(' delete ');
                writeln;
                end; (Execute Help}
                (
                The user has typed a quit command.
                }
                procedure ExecuteQuit (var line: LineType;
                var history: SequenceType; var status: StatusType);
                begin (Execute Quit}
                writeln('Leaving the history editor.');
                end; {Execute Quit}
                {
                Execute the given command. Its remaining arguments are still on line.
                }
                procedure ExecuteCommand (var line: LineType; command: CommandType;
                var history: SequenceType; var status: StatusType);
                begin (Execute Command}
                case command of
                LISTCMD: ExecuteList(line, history, status);
                TIDDCMD: ExecuteAdd(line, history, status);
                DELETECMD: ExecuteDelete(line, history, status);
                HELPCMD: ExecuteHelp(line, history, status);
                QUITCMD: ExecuteQuit(line, history, status);
                end;
                end; (Execute Command}
                {*** main program ***}
                begin
                Initialize(history) ;
                done := false;
                repeat
                GetCommand(line, command, status);
                if status = SUCCESS then begin
                ExecuteCommand(line, command, history, status);
                end;
                if status <> SUCCESS then begin
                PrintErrorMsg(status);
                end;
                until command = QUITCMD;
                end.
                </p>
                <h2 style="color: #e0214d;background: lavenderblush;">Revisions for the "Get a Complete Legal Command" Approach</h2>
                <p style="font:16px Courier New">
                  const
                MAXCMDLEN = 3;
                type
                WordArrayType = record
                length: integer;
                words: array[1..MAXCMDLEN] of WordType;
                end;
                StatusType = (SUCCESS, NOINPUT, LINETOOLONG, NOWORD, WORDTOOLONG,
                NOCOMMAND, BADCOMMAND, NODATE, TOOMANYDATES, BADNUM, BADSEP,
                EXTRAJUNK, BADDATE, ALREADYTHERE, NOTTHERE, EMPTYRANGE);
                CmdWordType = (LISTCMD, ADDCMD, DELETECMD, HELPC^, QUITCMD, UNKNOWN);
                CommandType = record
                cmdWord: CmdWordType;
                numArgs: integer;
                args: array[1..2] of DateType;
                </p>

              </article>
            <footer>
                <ol id="page-numbers">
                    <li>65</li>
                    <li>66</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
              <p style="font:16px Courier New">
                end;
                  {
                  Get all the words on the line and return them in words. There can be
                  no more than MAXCMDLEN words on the line; if more are provided,
                  indicate error in status.
                  }
                  procedure GetWords (var line: LineType;
                  var words: WordArrayType; var status: StatusType);
                  var
                  done: boolean; word: WordType;
                  begin {Get Words}
                  words.length := 0;
                  done := false;
                  while not done do begin
                  GetWord(line, word, status);
                  if status = NOWORD then begin
                  status := SUCCESS;
                  done := true;
                  end else if words.length = MAXCMDLEN then begin
                  status := TOOMANYDATES;
                  done := true;
                  end else begin
                  words.length := words.length + 1;
                  words.words[words.length] := word;
                  end;
                  end;
                  end; {Get Words}
                  {*** Command-scanning procedures ***}
                  {
                  Convert the first word in words to a command. Return the result in
                  command, and indicate success or any irregularities in status.
                  }
                  procedure ConvertToCommand (var words: WordArrayType;
                  var command: CommandType; var status: StatusType);
                  var
                  word: WordType;
                  begin {Convert to Command}
                  status := SUCCESS;
                  command. cmdWord : = UNKNOWN;
                  if words.length = 0 then begin
                  status := NOCOMMAND;
                  end else if words.words[1] = LISTWORD then begin
                  command.cmdWord := LISTCMD;
                  command.numArgs := words.length - 1;
                  end else if words.words[1] = ADDWORD then begin
                  command.cmdWord := ADDCMD;
                  if words.length < 2 then begin
                  status := NODATE;
                  end else if words.length > 2 then begin
                  status := TOOMANYDATES;
                  end else begin
                  command.numArgs := 1;
                  end;end else if words.words[1] = DELETEWORD then begin
                  connmand. cmdWord := DELETECMD;
                  if words.length < 2 then begin
                  status := NODATE;
                  end else if words.length > 2 then begin
                  status := TOOtmNYDATES;
                  end else begin
                  command.numArgs := 1;
                  end;
                  end else if words.words[1] = HELPWORD then begin
                  command.cmdWord := HELPCMD;
                  command.numArgs := 0;
                  end else if words.words[1] = QUITWORD then begin
                  command.cmdWord := QUITCMD;
                  command.numArgs := 0;
                  end else begin
                  status := BADCOMMAND;
                  end;
                  end; {Convert to Command}
                  {
                  Convert remaining words in words to date arguments in command.
                  }
                  procedure ConvertToArgs (words: WordArrayType; var command: CommandType;
                  var status: StatusType);
                  begin (Convert to Arguments}
                  if command.numArgs > 0 then begin
                  ConvertToDate(words.words[2], command.args[1], status);
                  end;
                  if (status = SUCCESS) and (command.numArgs > 1) then begin
                  ConvertToDate(words.words[3], command.args[2], status);
                  end;
                  end; (Convert to Arguments}
                  {
                  Get a command from the user. If the user types an illegal command,
                  indicate the fact in status.
                  }
                  procedure GetCommand (var line: LineType;
                  var command: CommandType; var status: StatusType);
                  var
                  words: WordArrayType;
                  begin (Get a Command}
                  write('CGMMAND? ');
                  GetLine(line, status);
                  if status = NGINPUT then begin
                  command.cmdWord := QUITCMD;
                  command.numArgs := 0;
                  status := SUCCESS;
                  end else begin
                  if status = SUCCESS then begin
                  GetWords(line, words, status);
                  end;
                  if status = SUCCESS then begin
                  ConvertToCommand(words, command, status);
                  end;
                  </p>



                </article>
            <footer>
                <ol id="page-numbers">
                    <li>67</li>
                    <li>68</li>
                </ol>
            </footer>
        </section>
         <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>
               <p style="font:16px Courier New">
                if status = SUCCESS then begin
                      ConvertToArgs(words, command, status);
                      end;
                      end;
                      end; {Get a Command}
                      {*** command interpreting procedures ***}
                      {
                      Execute a legal list command.
                      }
                      procedure ExecuteList (command: CommandType;
                      var history: SequenceType; var status: StatusType);
                      var
                      found: boolean; entry: EntryType; position: PositionType;
                      begin {Execute List}
                      case command.numArgs of
                      0: PrintAll(history) ;
                      1: begin
                      Find(history, command.args[1], found, entry, position);
                      if found then begin
                      PrintEntry(entry);
                      end else begin
                      status := NOTTHERE;
                      end;
                      end;
                      2: begin
                      Find(history, command.args[2], found, entry, position);
                      if not (AtOrBefore(entry.date, command.args[2])
                      and AtOrBefore(command.args[1], entry.date)) then begin
                      status := EMPTYRANGE;
                      end else begin
                      PrintEntry (entry);
                      PrintUpTo(history, command.args[1], position);
                      end;
                      end;
                      end;
                      end; {Execute List}
                      {
                      Execute a legal add command.
                      }
                      procedure ExecuteAdd (var command: CommandType;
                      var history: SequenceType; var status: StatusType);
                      var
                      found: boolean; entry: EntryType; position: PositionType;
                      begin {Execute Add}
                      Find(history, command.args[1], found, entry, position);
                      if found then begin
                      status := ALREADYTHERE;
                      end else begin
                      entry.date := command.args[l];
                      ReadEntry (entry);
                      Insert(history, entry, position);
                      end;
                      end; {Execute Add}
                      {
                      Execute a legal delete command.
                      }
                      procedure ExecuteDelete (var command: CommandType;
                      var histoiry: SequenceType; var status: StatusType);
                      var
                      found: boolean; entry: EntryType; position: PositionType;
                      begin {Execute Delete}
                      Find(history, command.args[1], found, entry, position);
                      if not found then begin
                      status := NOTTHERE;
                      end else begin
                      entry.date := command.args[1];
                      Delete (hist02ry, position);
                      end;
                      end; (Execute Delete)
                      (
                      Execute a legal command.
                      }
                      procedure ExecuteCommand (command: CommandType;
                      var history: SequenceType; var status: StatusType);
                      begin (Execute a Command)
                      case command.cmdWord of
                      LISTCMD: ExecuteList (command, hist03ry, status);
                      ADDCMD: ExecuteAdd(command, history, status);
                      DELETECMD: ExecuteDelete(command, history, status);
                      HELPCMD: ExecuteHelp(command, history, status);
                      QUITCMD: ExecuteQuit(command, history, status);
                      end;
                      end; (Execute a Command)
                      {*** main program ***)
                      begin
                      Initialize(history) ;
                      done := false;
                      repeat
                      GetCommand(line, command, status);
                      if status = SUCCESS then begin
                      ExecuteCommand(command, history, status);
                      end;
                      if status <> SUCCESS then begin
                      PrintErrorMsg(status);
                      end;
                      end.
                      286
                      </p>


              
                </article>
            <footer>
                <ol id="page-numbers">
                    <li>69</li>
                    <li>70</li>
                </ol>
            </footer>
        </section>

 <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>



              
                </article>
            <footer>
                <ol id="page-numbers">
                    <li>31</li>
                    <li>32</li>
                </ol>
            </footer>
        </section>

 <section class="open-book">
            <header id="Chap">
                <h1>Chapter 9</h1>
                <h6>Durk Jan de Bruin</h6>
            </header>
            <article>



              
                </article>
            <footer>
                <ol id="page-numbers">
                    <li>31</li>
                    <li>32</li>
                </ol>
            </footer>
        </section>





    </div>
</div>
</body>
</html>
